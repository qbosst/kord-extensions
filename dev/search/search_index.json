{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Kord Extensions is an addon for the excellent Kord library . It intends to provide a framework for larger bot projects, with easy-to-use commands, rich argument parsing and event handling, wrapped up into individual extension classes. The approach taken here is relatively different from a lot of Kotlin libraries, many of which prefer to provide a DSL for quickly prototyping or implementing a small application. Instead, discord.py (the Discord library for Python) is a primary source of inspiration for our fairly object-oriented design, especially where it comes to its extensions (which are known as cogs in discord.py). Despite this, we still strive to provide an idiomatic API that makes full use of Kotlin's niceties. Why not kordx.commands? Kord has released their own command framework, kordx.commands . It's a competent library, but it takes some very different approaches to solving the same problems Kord Extensions does. Most notably, it requires the use of kapt and makes use of an annotation-based autowire system for getting things registered. In contrast, Kord Extensions provides a less magical approach that is more closely tied to object-oriented programming, and may be more suitable for embedding into other applications. In addition, it provides many useful utilities and niceties that make working with Kord a breeze. At the end of the day, though, the choice is yours - both approaches have pros and cons, and it's worth checking both out to see what you like better! Usage \u00b6 To make use of Kord Extensions, update your build script to add https://maven.kotlindiscord.com/repository/maven-public/ as a Maven repository, and use com.kotlindiscord.kord.extensions:kord-extensions:VERSION as the Maven coordinate. Click on the badges at the top of this page to find a full list of all snapshot and release versions. For more specific directions for individual build systems, take a look at the Getting Started guide .","title":"Home"},{"location":"#home","text":"Kord Extensions is an addon for the excellent Kord library . It intends to provide a framework for larger bot projects, with easy-to-use commands, rich argument parsing and event handling, wrapped up into individual extension classes. The approach taken here is relatively different from a lot of Kotlin libraries, many of which prefer to provide a DSL for quickly prototyping or implementing a small application. Instead, discord.py (the Discord library for Python) is a primary source of inspiration for our fairly object-oriented design, especially where it comes to its extensions (which are known as cogs in discord.py). Despite this, we still strive to provide an idiomatic API that makes full use of Kotlin's niceties. Why not kordx.commands? Kord has released their own command framework, kordx.commands . It's a competent library, but it takes some very different approaches to solving the same problems Kord Extensions does. Most notably, it requires the use of kapt and makes use of an annotation-based autowire system for getting things registered. In contrast, Kord Extensions provides a less magical approach that is more closely tied to object-oriented programming, and may be more suitable for embedding into other applications. In addition, it provides many useful utilities and niceties that make working with Kord a breeze. At the end of the day, though, the choice is yours - both approaches have pros and cons, and it's worth checking both out to see what you like better!","title":"Home"},{"location":"#usage","text":"To make use of Kord Extensions, update your build script to add https://maven.kotlindiscord.com/repository/maven-public/ as a Maven repository, and use com.kotlindiscord.kord.extensions:kord-extensions:VERSION as the Maven coordinate. Click on the badges at the top of this page to find a full list of all snapshot and release versions. For more specific directions for individual build systems, take a look at the Getting Started guide .","title":"Usage"},{"location":"getting-started/","text":"Getting Started \u00b6 We recommend making use of Gradle for your build scripts, with a kordexVersion entry in your gradle.properties . Please note that Kord (and Kord Extensions) requires Kotlin 1.4 or later . build.gradle.kts 1 2 3 4 5 6 7 8 9 10 repositories { maven { name = \"Kotlin Discord\" url = uri ( \"https://maven.kotlindiscord.com/repository/maven-public/\" ) } } dependencies { implementation ( \"com.kotlindiscord.kord.extensions:kord-extensions: $ kordexVersion \" ) } build.gradle 1 2 3 4 5 6 7 8 9 10 repositories { maven { name = \"Kotlin Discord\" url = \"https://maven.kotlindiscord.com/repository/maven-public/\" } } dependencies { implementation \"com.kotlindiscord.kord.extensions:kord-extensions:$kordexVersion\" } pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <project> <repositories> <repository> <id> kotlin-discord </id> <name> Kotlin Discord </name> <url> https://maven.kotlindiscord.com/repository/maven-public/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.kotlindiscord.kord.extensions </groupId> <artifactId> kord-extensions </artifactId> <version> VERSION </version> </dependency> </dependencies> </project> A Basic Extension \u00b6 Kord Extensions is a relatively complex library, but the API it provides is fairly simple. In this example, we'll create an extension containing a command, and we'll create a bot with that extension installed on it. Initial Files \u00b6 Create an extension by extending the Extension class. TestExtension.kt \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TestExtension : Extension () { override val name = \"test\" // The registered name for our extension class TestArgs : Arguments () { // The arguments our command takes // A single required string argument val string by string ( \"string\" , \"String argument\" ) // Multiple boolean arguments, requiring at least one val bools by booleanList ( \"bools\" , \"Multiple boolean arguments\" ) } // This will be called when the extension gets set up override suspend fun setup () { command ( :: Arguments ) { // Define a command // The name of the command name = \"test\" // A description for the help command to show description = \"Test command, please ignore\" action { // This block will be executed when the command is run message . channel . createEmbed { // Kord: Create an embed title = \"Test response\" description = \"Test description\" field { name = \"String\" value = arguments . string // Required string is never null } field { name = \"Bools ( ${ arguments . bools . size } )\" value = arguments . bools . joinToString ( \", \" ) { \"` $ it `\" } } } } } } } Finally, create your main function, creating a bot, adding your extension to it and starting it up. 1 2 3 4 5 6 7 8 9 10 11 12 suspend fun main () { // New instance of the bot provided by Kord Extensions val bot = ExtensibleBot ( env ( \"TOKEN\" ) !! ) { // Discord bot token for logging in, using the env util function extensions { // Add the extension, the bot will instantiate it add ( :: TestExtension ) } } // Start the bot, blocking the current coroutine bot . start () } Test it out \u00b6 Set the TOKEN environment variable to a Discord bot token, and run your application. Wait for it to connect, and send !help test in a DM or any channel the bot has access to. Now, try running the command! For example, !test String yes no false will give you:","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"We recommend making use of Gradle for your build scripts, with a kordexVersion entry in your gradle.properties . Please note that Kord (and Kord Extensions) requires Kotlin 1.4 or later . build.gradle.kts 1 2 3 4 5 6 7 8 9 10 repositories { maven { name = \"Kotlin Discord\" url = uri ( \"https://maven.kotlindiscord.com/repository/maven-public/\" ) } } dependencies { implementation ( \"com.kotlindiscord.kord.extensions:kord-extensions: $ kordexVersion \" ) } build.gradle 1 2 3 4 5 6 7 8 9 10 repositories { maven { name = \"Kotlin Discord\" url = \"https://maven.kotlindiscord.com/repository/maven-public/\" } } dependencies { implementation \"com.kotlindiscord.kord.extensions:kord-extensions:$kordexVersion\" } pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <project> <repositories> <repository> <id> kotlin-discord </id> <name> Kotlin Discord </name> <url> https://maven.kotlindiscord.com/repository/maven-public/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.kotlindiscord.kord.extensions </groupId> <artifactId> kord-extensions </artifactId> <version> VERSION </version> </dependency> </dependencies> </project>","title":"Getting Started"},{"location":"getting-started/#a-basic-extension","text":"Kord Extensions is a relatively complex library, but the API it provides is fairly simple. In this example, we'll create an extension containing a command, and we'll create a bot with that extension installed on it.","title":"A Basic Extension"},{"location":"getting-started/#initial-files","text":"Create an extension by extending the Extension class.","title":"Initial Files"},{"location":"getting-started/#testextensionkt","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TestExtension : Extension () { override val name = \"test\" // The registered name for our extension class TestArgs : Arguments () { // The arguments our command takes // A single required string argument val string by string ( \"string\" , \"String argument\" ) // Multiple boolean arguments, requiring at least one val bools by booleanList ( \"bools\" , \"Multiple boolean arguments\" ) } // This will be called when the extension gets set up override suspend fun setup () { command ( :: Arguments ) { // Define a command // The name of the command name = \"test\" // A description for the help command to show description = \"Test command, please ignore\" action { // This block will be executed when the command is run message . channel . createEmbed { // Kord: Create an embed title = \"Test response\" description = \"Test description\" field { name = \"String\" value = arguments . string // Required string is never null } field { name = \"Bools ( ${ arguments . bools . size } )\" value = arguments . bools . joinToString ( \", \" ) { \"` $ it `\" } } } } } } } Finally, create your main function, creating a bot, adding your extension to it and starting it up. 1 2 3 4 5 6 7 8 9 10 11 12 suspend fun main () { // New instance of the bot provided by Kord Extensions val bot = ExtensibleBot ( env ( \"TOKEN\" ) !! ) { // Discord bot token for logging in, using the env util function extensions { // Add the extension, the bot will instantiate it add ( :: TestExtension ) } } // Start the bot, blocking the current coroutine bot . start () }","title":"TestExtension.kt"},{"location":"getting-started/#test-it-out","text":"Set the TOKEN environment variable to a Discord bot token, and run your application. Wait for it to connect, and send !help test in a DM or any channel the bot has access to. Now, try running the command! For example, !test String yes no false will give you:","title":"Test it out"},{"location":"concepts/bot/","text":"The Bot Object \u00b6 The bot object is the core of your application. All bots that make use of Kord Extensions must make use of the ExtensibleBot class - usually by creating an instance of it and using it as a jumping-off point. Extending the ExtensibleBot class Generally speaking, it's best to use ExtensibleBot directly and approach us if there's some functionality missing you need, but the option to extend it is always there if you have a very niche use-case. If you're not sure whether your use-case is appropriate for a wider public release, please open an issue - we're always happy to have a chat with you! Creating a Bot \u00b6 The first thing you'll want to do is create an instance of ExtensibleBot. A basic setup looks something like this: 1 2 3 4 5 6 7 8 val token = \"...\" // Get your bot token val commandPrefix = \"!\" // Prefix required before all command invocations - \"!\" is the default and can be omitted val bot = ExtensibleBot ( token ) { messageCommands { defaultPrefix = commandPrefix } } The ExtensibleBot class is configured using a builder pattern, providing a set of properties and DSL functions that you can make use of to configure your bot. Name Type Default Description koinLogLevel Level ERROR Koin logger level cache DSL function Configure the bot's caching options using a builder commands DSL function Configure the bot's command options using a builder extensions DSL function Configure the bot's extension options using a builder, and add custom extensions hooks DSL function Register lambdas that run at various stages in the bot's lifecycle intents DSL function Configure the bot's intents using a builder members DSL function Configure the bot's member-related options using a builder presence DSL function Configure the bot's initial presence using a builder Each of the DSL functions configures a specific part of the bot, and they're documented in their own sections below. Cache configuration \u00b6 1 2 3 4 5 6 7 8 9 val bot = ExtensibleBot ( token ) { cache { cachedMessages = null kord { // https://github.com/kordlib/kord/wiki/Caching messages ( MySpecialCache ()) } } } Name Type Default Description cachedMessages Int? 10_000 Number of messages to store in Kord's cache by default - set this to null to disable, or if you're customizing Kord's message cache yourself using the kord DSL function kord DSL function Customize Kord's cache yourself using a builder - for more information, see Kord's wiki on caching transformCache DSL function Interact with Kord's DataCache object before it connects to Discord - for more information, see Kord's wiki on caching Command configuration \u00b6 Kord Extensions supports two types of commands - message commands and slash commands. They are configured separately. Message commands \u00b6 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token ) { messageCommands { defaultPrefix = \"?\" invokeOnMention = true } } Name Type Default Description check DSL function Register a check that will be applied to all message commands. defaultPrefix String ! Prefix required before all command invocations enabled Boolean true Whether to support registration and invocation of message commands invokeOnMention Boolean true Whether commands may also be invoked by mentioning the bot messageRegistry DSL Functon If you'd like to use a MessageCommandRegistry subclass, then you can register a builder that returns it here. prefix DSL Function Register a receiver function for MessageEvent objects, that takes the configured defaultPrefix and returns a String that should be used as the message command prefix, given the context. This can be used to, for example, set up unique command prefixes for different guilds. Note: this is used in several places, and not just the command invocation logic - so make sure you don't interact with Discord any more than you have to! threads Int CPus * 2 How many threads to use for the command execution threadpool Slash commands \u00b6 1 2 3 4 5 val bot = ExtensibleBot ( token ) { slashCommands { enabled = true } } Name Type Default Description check DSL Function Register a check that will be applied to all slash commands. defaultGuild DSL Function null For testing, specify a guild ID to use for all slash commands that would normally be global. You can still override this by using the guild() function provided when defining your slash commands. enabled Boolean false Whether to support registration and invocation of slash commands. slashRegistry DSL Function If you'd like to use a SlashCommandRegistry subclass, then you can register a builder that returns it here - most likely the constructor. Extensions configuration \u00b6 For more information on what extensions are and how they work, please see the Extensions concept page . 1 2 3 4 5 6 7 8 val bot = ExtensibleBot ( token ) { extensions { sentry = false add ( :: LogsExtension ) add ( :: TestExtension ) } } Name Type Default Description add Function Use this function to add your own custom extensions to the bot help DSL Function Used to configure the bundled help extension sentry Boolean true Whether to enabled the bundled Sentry extension External modules that add extensions are free to add extension functions to this class, which gives users a convenient way to configure them. If you're using an external module, we recommend reading the documentation for any modules you may be using. Help Extension \u00b6 1 2 3 4 5 6 7 8 9 10 val bot = ExtensibleBot ( token ) { extensions { help { colour { DISCORD_GREEN } deletePaginatorOnTimeout = true deleteInvocationOnPaginatorTimeout = true } } } Name Type Default Description check DSL Function Register a check that will be applied to all help extension commands colour DSL Function Register a callback returning a Kord Color object to use it for the help command pages - this is called for every page generated, so feel free to return randomized colours if you'd like to deleteInvocationOnPaginatorTimeout Boolean false Whether to try to delete the user's !help command when the paginator times out deletePaginatorOnTimeout Boolean false Whether to delete the help command's output paginator when it times out enableBundledExtension Boolean true Whether to enable the bundled help extension paginatorTimeout Long 60_000 How long to wait until a paginator times out and becomes unusable - defaults to 60 seconds pingInReply Boolean true Whether to ping users in response to their help command invocations Hooks \u00b6 Hooks allow you to set up lambdas that are to be run at various points in the bot's lifecycle, allowing you to set up the bot precisely how you need it. All hook functions may be called multiple times, if you need to add multiple hooks for the same lifecycle stage. 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token ) { hooks { created { println ( \"ExtensibleBot object created, but not yet set up.\" ) } } } ExtensibleBotBuilder subclasses Please note that some hooks are called by the build function - if you override this function, you need to remember to similarly call the corresponding hook functions yourself. Property Default Description kordShutdownHook true Whether Kord should register a hook that logs out of the gateway as part of the application shutdown process Lifecycle Function Description afterExtensionsAdded Lambdas registered here are called after all the extensions specified in the extensions builder above have been registered afterKoinSetup Lambdas registered here are called just after Koin has been set up - you can register overriding modules here via loadModule {} beforeExtensionsAdded Lambdas registered here are called before all the extensions specified in the extensions builder above have been registered beforeKoinSetup Lambdas registered here are called just before Koin is set up, right after the startKoin call - you can register modules early here via loadModule {} beforeStart Lambdas registered here are called just before the bot tries to connect to Discord created Lambdas registered here are called just after the ExtensibleBot object has been created, before it's been set up extensionAdded Lambdas registered here are called every time an extension is added successfully, with the extension object as a parameter setup Lambdas registered here are called after the ExtensibleBot object has been created and set up I18n configuration \u00b6 The i18n builder allows you to configure the default locale, and register locale resolvers and a translations provider. The default locale is SupportedLocales.ENGLISH , if you don't change it. 1 2 3 4 5 val bot = ExtensibleBot ( token ) { i18n { defaultLocale = SupportedLocales . ENGLISH } } Property Type Default Description defaultLocale Locale ENGLISH The default locale to use, when your locale resolvers don't return a different one translationsProvider TranslationsProvider ResourceBundleTranslations Implementation of TranslationsProvider responsible for transforming translation keys into strings, replacing placeholders as necessary Function Description localeResolver Call this to register a lambda (or callable) that takes a Guild? , Channel and User? argument and returns a Locale object, or null to move on to the next resolver - you can use this to set up, for example, guild-specific locales translationsProvider Call this to register a builder (usually a constructor) returning a TranslationsProvider instance - this is called immediately, you can't conditionally dispatch to multiple providers with this For more information on i18n and translations, see the i18n page . Intent configuration \u00b6 This matches Kord's intents API. For a list of available intents, see the Kord documentation . 1 2 3 4 5 val bot = ExtensibleBot ( token ) { intents { + Intents . all } } Member-related configuration \u00b6 This builder configures automatic cache filling for members that are part of the guilds the bot is present on. Please note that you will need the GUILD_MEMBERS privileged intent to fill the cache with guild member information, and the GUILD_PRESENCES privileged intent if you'd also like to fill the cache with (and receive) their presences. 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token ) { members { fillPresences = true all () } } Name Type Description all Function State that you'd like to fill the cache with member info for all guilds the bot is part of fill Function Use this function to specify guild IDs (or collections of guild IDs) that you'd like to cache member information for fillPresences Boolean? Set this to true to state that you'd like to receive user presences none Function State that you would not like to cache any member info - this is the default behaviour Presence configuration \u00b6 This matches Kord's initial presence API. For more information, see the Kord documentation . 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token ) { presence { status = PresenceStatus . Online playing ( \"!help for command help\" ) } } Starting up \u00b6 When you're all set up, and you've registered all your extensions, you can call the start function to create a Kord instance and connect to Discord. 1 bot . start () Not Implemented: Sharding Sharding is currently not supported. We haven't had a chance to look at it yet, as none of the developers are currently working on bots that require sharding. If you need sharding, please contact us and we can work out the details. Properties \u00b6 A few properties are available to you, for getting access to a few internals. Further properties There are other non-private properties available, but they aren't necessarily something you'll need to touch. Most of the properties are open to facilitate niche use-cases that require extending the ExtensibleBot class. This object used to have many other useful properties here, but to keep things clean those properties have been moved and should now be accessed via Koin. For more information, see the Koin integration page . Name Type Description eventHandlers List <EventHandler> All currently-registered event handler objects extensions Map <String, Extension> All currently-loaded extension objects Functions \u00b6 A number of functions are available to you as well. Further functions There are other non-private functions available, but they aren't necessarily something you'll need to touch. Most of the functions are open to facilitate niche use-cases that require extending the ExtensibleBot class, but a handful are inline for the sake of avoiding function call overhead or making use of reified types. Name Description findExtension Find the first loaded extension matching the given type, or null if there isn't one findExtensions Get a list of all loaded extensions matching the given type loadExtension Set up a previously-unloaded extension start Connect to Discord, blocking the coroutine scope send Send an event to all event handlers - either a Kord Event or an ExtensionEvent object unloadExtension Tear down a previously-loaded extension","title":"The Bot Object"},{"location":"concepts/bot/#the-bot-object","text":"The bot object is the core of your application. All bots that make use of Kord Extensions must make use of the ExtensibleBot class - usually by creating an instance of it and using it as a jumping-off point. Extending the ExtensibleBot class Generally speaking, it's best to use ExtensibleBot directly and approach us if there's some functionality missing you need, but the option to extend it is always there if you have a very niche use-case. If you're not sure whether your use-case is appropriate for a wider public release, please open an issue - we're always happy to have a chat with you!","title":"The Bot Object"},{"location":"concepts/bot/#creating-a-bot","text":"The first thing you'll want to do is create an instance of ExtensibleBot. A basic setup looks something like this: 1 2 3 4 5 6 7 8 val token = \"...\" // Get your bot token val commandPrefix = \"!\" // Prefix required before all command invocations - \"!\" is the default and can be omitted val bot = ExtensibleBot ( token ) { messageCommands { defaultPrefix = commandPrefix } } The ExtensibleBot class is configured using a builder pattern, providing a set of properties and DSL functions that you can make use of to configure your bot. Name Type Default Description koinLogLevel Level ERROR Koin logger level cache DSL function Configure the bot's caching options using a builder commands DSL function Configure the bot's command options using a builder extensions DSL function Configure the bot's extension options using a builder, and add custom extensions hooks DSL function Register lambdas that run at various stages in the bot's lifecycle intents DSL function Configure the bot's intents using a builder members DSL function Configure the bot's member-related options using a builder presence DSL function Configure the bot's initial presence using a builder Each of the DSL functions configures a specific part of the bot, and they're documented in their own sections below.","title":"Creating a Bot"},{"location":"concepts/bot/#cache-configuration","text":"1 2 3 4 5 6 7 8 9 val bot = ExtensibleBot ( token ) { cache { cachedMessages = null kord { // https://github.com/kordlib/kord/wiki/Caching messages ( MySpecialCache ()) } } } Name Type Default Description cachedMessages Int? 10_000 Number of messages to store in Kord's cache by default - set this to null to disable, or if you're customizing Kord's message cache yourself using the kord DSL function kord DSL function Customize Kord's cache yourself using a builder - for more information, see Kord's wiki on caching transformCache DSL function Interact with Kord's DataCache object before it connects to Discord - for more information, see Kord's wiki on caching","title":"Cache configuration"},{"location":"concepts/bot/#command-configuration","text":"Kord Extensions supports two types of commands - message commands and slash commands. They are configured separately.","title":"Command configuration"},{"location":"concepts/bot/#message-commands","text":"1 2 3 4 5 6 7 val bot = ExtensibleBot ( token ) { messageCommands { defaultPrefix = \"?\" invokeOnMention = true } } Name Type Default Description check DSL function Register a check that will be applied to all message commands. defaultPrefix String ! Prefix required before all command invocations enabled Boolean true Whether to support registration and invocation of message commands invokeOnMention Boolean true Whether commands may also be invoked by mentioning the bot messageRegistry DSL Functon If you'd like to use a MessageCommandRegistry subclass, then you can register a builder that returns it here. prefix DSL Function Register a receiver function for MessageEvent objects, that takes the configured defaultPrefix and returns a String that should be used as the message command prefix, given the context. This can be used to, for example, set up unique command prefixes for different guilds. Note: this is used in several places, and not just the command invocation logic - so make sure you don't interact with Discord any more than you have to! threads Int CPus * 2 How many threads to use for the command execution threadpool","title":"Message commands"},{"location":"concepts/bot/#slash-commands","text":"1 2 3 4 5 val bot = ExtensibleBot ( token ) { slashCommands { enabled = true } } Name Type Default Description check DSL Function Register a check that will be applied to all slash commands. defaultGuild DSL Function null For testing, specify a guild ID to use for all slash commands that would normally be global. You can still override this by using the guild() function provided when defining your slash commands. enabled Boolean false Whether to support registration and invocation of slash commands. slashRegistry DSL Function If you'd like to use a SlashCommandRegistry subclass, then you can register a builder that returns it here - most likely the constructor.","title":"Slash commands"},{"location":"concepts/bot/#extensions-configuration","text":"For more information on what extensions are and how they work, please see the Extensions concept page . 1 2 3 4 5 6 7 8 val bot = ExtensibleBot ( token ) { extensions { sentry = false add ( :: LogsExtension ) add ( :: TestExtension ) } } Name Type Default Description add Function Use this function to add your own custom extensions to the bot help DSL Function Used to configure the bundled help extension sentry Boolean true Whether to enabled the bundled Sentry extension External modules that add extensions are free to add extension functions to this class, which gives users a convenient way to configure them. If you're using an external module, we recommend reading the documentation for any modules you may be using.","title":"Extensions configuration"},{"location":"concepts/bot/#help-extension","text":"1 2 3 4 5 6 7 8 9 10 val bot = ExtensibleBot ( token ) { extensions { help { colour { DISCORD_GREEN } deletePaginatorOnTimeout = true deleteInvocationOnPaginatorTimeout = true } } } Name Type Default Description check DSL Function Register a check that will be applied to all help extension commands colour DSL Function Register a callback returning a Kord Color object to use it for the help command pages - this is called for every page generated, so feel free to return randomized colours if you'd like to deleteInvocationOnPaginatorTimeout Boolean false Whether to try to delete the user's !help command when the paginator times out deletePaginatorOnTimeout Boolean false Whether to delete the help command's output paginator when it times out enableBundledExtension Boolean true Whether to enable the bundled help extension paginatorTimeout Long 60_000 How long to wait until a paginator times out and becomes unusable - defaults to 60 seconds pingInReply Boolean true Whether to ping users in response to their help command invocations","title":"Help Extension"},{"location":"concepts/bot/#hooks","text":"Hooks allow you to set up lambdas that are to be run at various points in the bot's lifecycle, allowing you to set up the bot precisely how you need it. All hook functions may be called multiple times, if you need to add multiple hooks for the same lifecycle stage. 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token ) { hooks { created { println ( \"ExtensibleBot object created, but not yet set up.\" ) } } } ExtensibleBotBuilder subclasses Please note that some hooks are called by the build function - if you override this function, you need to remember to similarly call the corresponding hook functions yourself. Property Default Description kordShutdownHook true Whether Kord should register a hook that logs out of the gateway as part of the application shutdown process Lifecycle Function Description afterExtensionsAdded Lambdas registered here are called after all the extensions specified in the extensions builder above have been registered afterKoinSetup Lambdas registered here are called just after Koin has been set up - you can register overriding modules here via loadModule {} beforeExtensionsAdded Lambdas registered here are called before all the extensions specified in the extensions builder above have been registered beforeKoinSetup Lambdas registered here are called just before Koin is set up, right after the startKoin call - you can register modules early here via loadModule {} beforeStart Lambdas registered here are called just before the bot tries to connect to Discord created Lambdas registered here are called just after the ExtensibleBot object has been created, before it's been set up extensionAdded Lambdas registered here are called every time an extension is added successfully, with the extension object as a parameter setup Lambdas registered here are called after the ExtensibleBot object has been created and set up","title":"Hooks"},{"location":"concepts/bot/#i18n-configuration","text":"The i18n builder allows you to configure the default locale, and register locale resolvers and a translations provider. The default locale is SupportedLocales.ENGLISH , if you don't change it. 1 2 3 4 5 val bot = ExtensibleBot ( token ) { i18n { defaultLocale = SupportedLocales . ENGLISH } } Property Type Default Description defaultLocale Locale ENGLISH The default locale to use, when your locale resolvers don't return a different one translationsProvider TranslationsProvider ResourceBundleTranslations Implementation of TranslationsProvider responsible for transforming translation keys into strings, replacing placeholders as necessary Function Description localeResolver Call this to register a lambda (or callable) that takes a Guild? , Channel and User? argument and returns a Locale object, or null to move on to the next resolver - you can use this to set up, for example, guild-specific locales translationsProvider Call this to register a builder (usually a constructor) returning a TranslationsProvider instance - this is called immediately, you can't conditionally dispatch to multiple providers with this For more information on i18n and translations, see the i18n page .","title":"I18n configuration"},{"location":"concepts/bot/#intent-configuration","text":"This matches Kord's intents API. For a list of available intents, see the Kord documentation . 1 2 3 4 5 val bot = ExtensibleBot ( token ) { intents { + Intents . all } }","title":"Intent configuration"},{"location":"concepts/bot/#member-related-configuration","text":"This builder configures automatic cache filling for members that are part of the guilds the bot is present on. Please note that you will need the GUILD_MEMBERS privileged intent to fill the cache with guild member information, and the GUILD_PRESENCES privileged intent if you'd also like to fill the cache with (and receive) their presences. 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token ) { members { fillPresences = true all () } } Name Type Description all Function State that you'd like to fill the cache with member info for all guilds the bot is part of fill Function Use this function to specify guild IDs (or collections of guild IDs) that you'd like to cache member information for fillPresences Boolean? Set this to true to state that you'd like to receive user presences none Function State that you would not like to cache any member info - this is the default behaviour","title":"Member-related configuration"},{"location":"concepts/bot/#presence-configuration","text":"This matches Kord's initial presence API. For more information, see the Kord documentation . 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token ) { presence { status = PresenceStatus . Online playing ( \"!help for command help\" ) } }","title":"Presence configuration"},{"location":"concepts/bot/#starting-up","text":"When you're all set up, and you've registered all your extensions, you can call the start function to create a Kord instance and connect to Discord. 1 bot . start () Not Implemented: Sharding Sharding is currently not supported. We haven't had a chance to look at it yet, as none of the developers are currently working on bots that require sharding. If you need sharding, please contact us and we can work out the details.","title":"Starting up"},{"location":"concepts/bot/#properties","text":"A few properties are available to you, for getting access to a few internals. Further properties There are other non-private properties available, but they aren't necessarily something you'll need to touch. Most of the properties are open to facilitate niche use-cases that require extending the ExtensibleBot class. This object used to have many other useful properties here, but to keep things clean those properties have been moved and should now be accessed via Koin. For more information, see the Koin integration page . Name Type Description eventHandlers List <EventHandler> All currently-registered event handler objects extensions Map <String, Extension> All currently-loaded extension objects","title":"Properties"},{"location":"concepts/bot/#functions","text":"A number of functions are available to you as well. Further functions There are other non-private functions available, but they aren't necessarily something you'll need to touch. Most of the functions are open to facilitate niche use-cases that require extending the ExtensibleBot class, but a handful are inline for the sake of avoiding function call overhead or making use of reified types. Name Description findExtension Find the first loaded extension matching the given type, or null if there isn't one findExtensions Get a list of all loaded extensions matching the given type loadExtension Set up a previously-unloaded extension start Connect to Discord, blocking the coroutine scope send Send an event to all event handlers - either a Kord Event or an ExtensionEvent object unloadExtension Tear down a previously-loaded extension","title":"Functions"},{"location":"concepts/checks/","text":"Checks \u00b6 The checks system provides a way for you define and make use of predicates that decide whether an event handler or command should execute. The concept is relatively simple - all checks receive an event, check whether execution should continue based on that event, and return a Boolean value that decides what happens next - true to continue, false to stop. Anything that makes use of checks will accept either a lambda, or a function reference. This allows you to create reusable check functions that can be imported and made use of throughout your bot. Checks suite \u00b6 Kord Extensions comes with a full suite of commonly-used checks. This suite includes checks that operate based on specific types, combinator checks that provide boolean operations on sets of other checks, and a set of utilities for writing your own checks or extracting information from Kord events. Event not supported? If an event is not supported by a check that you feel should be, please raise an issue with us - we'll look into it as quickly as we can. Kord does not provide generic interfaces for figuring out which events concern different types of entity, so we have to manually maintain utilities that match specific events by their types. Channels \u00b6 Note: All checks in this category take a DSL-style lambda argument that returns the type specified in the table below, or a Snowflake that should resolve to an entity of that type. Name Expected Type Description channelHigherOrEqual Channel Behavior Asserts that an event fired in a channel higher than or equal to the given channel channelHigher Channel Behavior Asserts that an event fired in a channel higher than the given channel channelLowerOrEqual Channel Behavior Asserts that an event fired in a channel lower than or equal to the given channel channelLower Channel Behavior Asserts that an event fired in a channel lower than the given channel inCategory Category Behavior Asserts that an event fired within the given channel category inChannel Channel Behavior Asserts that an event fired within the given channel notInCategory Category Behavior Asserts that an event did not fire within the given channel category notInChannel Channel Behavior Asserts that an event did not fire within the given channel Channel types \u00b6 Name Argument Description channelType Channel Type Asserts that an event fired within a channel matching the given type notChannelType Channel Type Asserts that an event did not fire within a channel matching the given type Guilds \u00b6 Note: All checks in this category take a DSL-style lambda argument that returns the type specified in the table below, or a Snowflake that should resolve to an entity of that type. Additionally, the anyGuild and noGuild checks are not currently able to tell the difference between an event that wasn't fired within a guild, and an event that fired within a guild the bot doesn't have access to, or that it can't get the GuildBehavior for (for example, due to a niche Kord configuration). Name Expected Type Description anyGuild Asserts that an event fired within any guild inGuild Guild Behavior Asserts that an event fired within the given guild noGuild Asserts that an event did not fire within a guild notInGuild Guild Behavior Asserts that an event did not fire within the given guild Members \u00b6 Channel overwrites Note that these checks currently only operate based on guild roles, and they ignore channel overwrites. If you need checks for channel overwrites then please let us know, and we'll try to figure out a good solution. Name Argument Description hasPermission Permission Asserts that an event was fired by a user with the given permission notHasPermission Permission Asserts that an event was fired by a user without the given permission Misc \u00b6 Name Expected Type Description isBot User Asserts that an event was fired by a user that is a bot isNotBot User Asserts that an event was fired by a user that is not a bot Roles \u00b6 Note: All checks in this category take a DSL-style lambda argument that returns the type specified in the table below, or a Snowflake that should resolve to an entity of that type. Name Expected Type Description hasRole Role Behavior Asserts that an event was fired by a user with the given role notHasRole Role Behavior Asserts that an event was fired by a user without the given role topRoleEqual Role Behavior Asserts that an event was fired by a user with a top role that matches the given role topRoleHigherOrEqual Role Behavior Asserts that an event was fired by a user with a top role higher than or equal to the given role topRoleHigher Role Behavior Asserts that an event was fired by a user with a top role higher than the given role topRoleLowerOrEqual Role Behavior Asserts that an event was fired by a user with a top role lower than or equal to the given role topRoleLower Role Behavior Asserts that an event was fired by a user with a top role lower than the given role topRoleNotEqual Role Behavior Asserts that an event was fired by a user with a top role that does not match the given role Combinators \u00b6 Combinator checks operate on a variable number of other checks, transforming their results as appropriate. They are also available as infix variants, if you prefer that syntax: ::noGuild or hasRole(ADMIN_ROLE) Name Argument Description and Checks Special check that passes if any of the given checks pass or Checks Special check that passes only if all of the given checks pass Utilities \u00b6 The following utilities are made use of in the other checks, but you can make use of them yourself if you need to try to extract a given type from any event. If an event is unsupported, then each of the below functions will return null . Please note that there are some events that these functions do support that may themselves return a nullable value when queried. As interaction events generally only contain Snowflake s, most of the below functions will query the Kord cache or REST when dealing with them. Name Return Type Notes channelFor Channel Behavior channelIdFor Long This function will return a Long taken from a Snowflake , rather than the Snowflake itself channelSnowflakeFor Snowflake This function is just like the previous, but will not unwrap the Snowflake guildFor Guild Behavior This function will query the Kord cache or REST for MessageCreateEvent and MessageUpdateEvent memberFor Member Behavior This function will query the Kord cache or REST for all supported events except for MemberJoinEvent and MemberUpdateEvent messageFor Message Behavior This function will query the Kord cache or REST for MessageUpdateEvent roleFor Role Behavior userFor User Behavior This function will query the Kord cache or REST for MessageUpdateEvent , and will only return the first user that isn't the bot for DMChannelCreateEvent , DMChannelDeleteEvent and DMChannelUpdateEvent (as we don't support selfbots) Creating reusable checks \u00b6 Checks concerning entities: Always resolve late! If you're writing a check that concerns a Kord entity - for example, a GuildBehavior or ChannelBehavior (or, indeed, Guild or Channel ), it's important that you provide two very specific implementations: A version that takes a lambda returning the entity you're checking, which is called within an inner function that is returned by your outer check function . A version that takes a Snowflake and wraps the lambda version you wrote above. The reason this is required is to ensure that extensions making use of these checks do not try to resolve entities before the bot has connected to Discord. If you require your user to directly pass entities to your check functions, or your check functions immediately try to resolve entities by calling the passed lambda too early, those extensions will throw exceptions when they're being registered. Here's an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public fun inChannel ( builder : suspend () -> ChannelBehavior ): suspend ( Event ) -> Boolean { val logger = KotlinLogging . logger ( \"com.kotlindiscord.kord.extensions.checks.inChannel\" ) suspend fun inner ( event : Event ): Boolean { val eventChannel = channelFor ( event ) if ( eventChannel == null ) { logger . nullChannel ( event ) return false } val channel = builder () return if ( eventChannel . id == channel . id ) { logger . passed () true } else { logger . failed ( \"Channel $ eventChannel is not the same as channel $ channel \" ) false } } return :: inner } All checks may be defined as functions, and all check functions will accept a function reference. We also provide a set of logger extension functions to make creating consistent log messages easier. As an example, it's common practise to define a \"default\" check that applies to most commands like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 suspend fun defaultCheck ( event : Event ): Boolean { val logger = KotlinLogging . logger ( \"my.package.defaultCheck\" ) val message = messageFor ( event ) ?. asMessage () return when { message == null -> { logger . nullMessage () false } message . author == null -> { logger . failed ( \"Message sent by a webhook or system message\" ) false } message . author !! . id == bot . kord . getSelf (). id -> { logger . failed ( \"We sent this message\" ) false } message . author !! . isBot -> { logger . failed ( \"This message was sent by another bot\" ) false } message . getChannelOrNull () is DmChannel -> { logger . passed ( \"This message was sent in a DM\" ) true } message . getGuildOrNull () ?. id != config . getGuild (). id -> { logger . failed ( \"Not in the correct guild\" ) false } else -> { logger . passed () true } } } If you've written a check that you think would be useful for most users (and it can be written in a generic way) then feel free to open an issue or pull request, and we'll look at getting it added to the framework proper.","title":"Checks"},{"location":"concepts/checks/#checks","text":"The checks system provides a way for you define and make use of predicates that decide whether an event handler or command should execute. The concept is relatively simple - all checks receive an event, check whether execution should continue based on that event, and return a Boolean value that decides what happens next - true to continue, false to stop. Anything that makes use of checks will accept either a lambda, or a function reference. This allows you to create reusable check functions that can be imported and made use of throughout your bot.","title":"Checks"},{"location":"concepts/checks/#checks-suite","text":"Kord Extensions comes with a full suite of commonly-used checks. This suite includes checks that operate based on specific types, combinator checks that provide boolean operations on sets of other checks, and a set of utilities for writing your own checks or extracting information from Kord events. Event not supported? If an event is not supported by a check that you feel should be, please raise an issue with us - we'll look into it as quickly as we can. Kord does not provide generic interfaces for figuring out which events concern different types of entity, so we have to manually maintain utilities that match specific events by their types.","title":"Checks suite"},{"location":"concepts/checks/#channels","text":"Note: All checks in this category take a DSL-style lambda argument that returns the type specified in the table below, or a Snowflake that should resolve to an entity of that type. Name Expected Type Description channelHigherOrEqual Channel Behavior Asserts that an event fired in a channel higher than or equal to the given channel channelHigher Channel Behavior Asserts that an event fired in a channel higher than the given channel channelLowerOrEqual Channel Behavior Asserts that an event fired in a channel lower than or equal to the given channel channelLower Channel Behavior Asserts that an event fired in a channel lower than the given channel inCategory Category Behavior Asserts that an event fired within the given channel category inChannel Channel Behavior Asserts that an event fired within the given channel notInCategory Category Behavior Asserts that an event did not fire within the given channel category notInChannel Channel Behavior Asserts that an event did not fire within the given channel","title":"Channels"},{"location":"concepts/checks/#channel-types","text":"Name Argument Description channelType Channel Type Asserts that an event fired within a channel matching the given type notChannelType Channel Type Asserts that an event did not fire within a channel matching the given type","title":"Channel types"},{"location":"concepts/checks/#guilds","text":"Note: All checks in this category take a DSL-style lambda argument that returns the type specified in the table below, or a Snowflake that should resolve to an entity of that type. Additionally, the anyGuild and noGuild checks are not currently able to tell the difference between an event that wasn't fired within a guild, and an event that fired within a guild the bot doesn't have access to, or that it can't get the GuildBehavior for (for example, due to a niche Kord configuration). Name Expected Type Description anyGuild Asserts that an event fired within any guild inGuild Guild Behavior Asserts that an event fired within the given guild noGuild Asserts that an event did not fire within a guild notInGuild Guild Behavior Asserts that an event did not fire within the given guild","title":"Guilds"},{"location":"concepts/checks/#members","text":"Channel overwrites Note that these checks currently only operate based on guild roles, and they ignore channel overwrites. If you need checks for channel overwrites then please let us know, and we'll try to figure out a good solution. Name Argument Description hasPermission Permission Asserts that an event was fired by a user with the given permission notHasPermission Permission Asserts that an event was fired by a user without the given permission","title":"Members"},{"location":"concepts/checks/#misc","text":"Name Expected Type Description isBot User Asserts that an event was fired by a user that is a bot isNotBot User Asserts that an event was fired by a user that is not a bot","title":"Misc"},{"location":"concepts/checks/#roles","text":"Note: All checks in this category take a DSL-style lambda argument that returns the type specified in the table below, or a Snowflake that should resolve to an entity of that type. Name Expected Type Description hasRole Role Behavior Asserts that an event was fired by a user with the given role notHasRole Role Behavior Asserts that an event was fired by a user without the given role topRoleEqual Role Behavior Asserts that an event was fired by a user with a top role that matches the given role topRoleHigherOrEqual Role Behavior Asserts that an event was fired by a user with a top role higher than or equal to the given role topRoleHigher Role Behavior Asserts that an event was fired by a user with a top role higher than the given role topRoleLowerOrEqual Role Behavior Asserts that an event was fired by a user with a top role lower than or equal to the given role topRoleLower Role Behavior Asserts that an event was fired by a user with a top role lower than the given role topRoleNotEqual Role Behavior Asserts that an event was fired by a user with a top role that does not match the given role","title":"Roles"},{"location":"concepts/checks/#combinators","text":"Combinator checks operate on a variable number of other checks, transforming their results as appropriate. They are also available as infix variants, if you prefer that syntax: ::noGuild or hasRole(ADMIN_ROLE) Name Argument Description and Checks Special check that passes if any of the given checks pass or Checks Special check that passes only if all of the given checks pass","title":"Combinators"},{"location":"concepts/checks/#utilities","text":"The following utilities are made use of in the other checks, but you can make use of them yourself if you need to try to extract a given type from any event. If an event is unsupported, then each of the below functions will return null . Please note that there are some events that these functions do support that may themselves return a nullable value when queried. As interaction events generally only contain Snowflake s, most of the below functions will query the Kord cache or REST when dealing with them. Name Return Type Notes channelFor Channel Behavior channelIdFor Long This function will return a Long taken from a Snowflake , rather than the Snowflake itself channelSnowflakeFor Snowflake This function is just like the previous, but will not unwrap the Snowflake guildFor Guild Behavior This function will query the Kord cache or REST for MessageCreateEvent and MessageUpdateEvent memberFor Member Behavior This function will query the Kord cache or REST for all supported events except for MemberJoinEvent and MemberUpdateEvent messageFor Message Behavior This function will query the Kord cache or REST for MessageUpdateEvent roleFor Role Behavior userFor User Behavior This function will query the Kord cache or REST for MessageUpdateEvent , and will only return the first user that isn't the bot for DMChannelCreateEvent , DMChannelDeleteEvent and DMChannelUpdateEvent (as we don't support selfbots)","title":"Utilities"},{"location":"concepts/checks/#creating-reusable-checks","text":"Checks concerning entities: Always resolve late! If you're writing a check that concerns a Kord entity - for example, a GuildBehavior or ChannelBehavior (or, indeed, Guild or Channel ), it's important that you provide two very specific implementations: A version that takes a lambda returning the entity you're checking, which is called within an inner function that is returned by your outer check function . A version that takes a Snowflake and wraps the lambda version you wrote above. The reason this is required is to ensure that extensions making use of these checks do not try to resolve entities before the bot has connected to Discord. If you require your user to directly pass entities to your check functions, or your check functions immediately try to resolve entities by calling the passed lambda too early, those extensions will throw exceptions when they're being registered. Here's an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public fun inChannel ( builder : suspend () -> ChannelBehavior ): suspend ( Event ) -> Boolean { val logger = KotlinLogging . logger ( \"com.kotlindiscord.kord.extensions.checks.inChannel\" ) suspend fun inner ( event : Event ): Boolean { val eventChannel = channelFor ( event ) if ( eventChannel == null ) { logger . nullChannel ( event ) return false } val channel = builder () return if ( eventChannel . id == channel . id ) { logger . passed () true } else { logger . failed ( \"Channel $ eventChannel is not the same as channel $ channel \" ) false } } return :: inner } All checks may be defined as functions, and all check functions will accept a function reference. We also provide a set of logger extension functions to make creating consistent log messages easier. As an example, it's common practise to define a \"default\" check that applies to most commands like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 suspend fun defaultCheck ( event : Event ): Boolean { val logger = KotlinLogging . logger ( \"my.package.defaultCheck\" ) val message = messageFor ( event ) ?. asMessage () return when { message == null -> { logger . nullMessage () false } message . author == null -> { logger . failed ( \"Message sent by a webhook or system message\" ) false } message . author !! . id == bot . kord . getSelf (). id -> { logger . failed ( \"We sent this message\" ) false } message . author !! . isBot -> { logger . failed ( \"This message was sent by another bot\" ) false } message . getChannelOrNull () is DmChannel -> { logger . passed ( \"This message was sent in a DM\" ) true } message . getGuildOrNull () ?. id != config . getGuild (). id -> { logger . failed ( \"Not in the correct guild\" ) false } else -> { logger . passed () true } } } If you've written a check that you think would be useful for most users (and it can be written in a generic way) then feel free to open an issue or pull request, and we'll look at getting it added to the framework proper.","title":"Creating reusable checks"},{"location":"concepts/commands/","text":"Commands \u00b6 If you want your bot to interact with users in a more complex manner than simply reacting to events, then you'll probably want to write some commands. Kord Extensions provides a robust and flexible commands system, built around a custom argument parsing solution that allows you to specify the arguments for your command in an entirely type-safe manner. We support both standalone and grouped commands, and you can even create your own specialised command types if you wish. That said, it's usually best to start with the basics. The basics \u00b6 Commands provide a way for you to specify a set of actions the bot can take on a user's behalf, specified using a prefixed message in a Discord channel or private message. Creating one is simple - just use the command function in your extension's setup function. 1 2 3 4 5 6 7 8 9 10 11 12 command { // this: Command name = \"ping\" // Command name (can be a translation key) aliases = arrayOf ( \"pong\" ) // Alternate command names (can be translation keys) description = \"Returns 'Pong!'\" // Help text for the help command (can be a translation key) check { event -> true } // Return `false` to prevent the action check ( :: returnTrue ) // You can also pass it a function action { // this: MessageCommandContext message . respond ( \"Pong!\" ) } } Use the check function to define a set of predicates that must all return true in order for the command's action to be run - you can read more about checks on the Checks page . If all the checks pass, the action lambda will be called. Note that the action lambda above is a receiver function, where this is bound to a MessageCommandContext object. Options \u00b6 Commands have quite a lot of options that you may be interested in while setting one up. The following properties are available right in the command lambda - please note that properties marked with are required and must be set in order to properly register a command. Name Type Description name String The primary name of the command, which must be unique throughout the bot and is used for invocation aliases Array <String> An array of secondary names to use for this command, which are also used for invocation and help commands aliasKey String? Instead of a list of aliases, you can provide a translation key here - this should refer to a comma-separated list of aliases in your translations description String A long description used by the help extension to describe the command - the first line of which should be a short summary enabled Boolean Defaulting to true , this can be set programmatically in order to entirely disable or re-enable the command hidden Boolean Default to false , this can be set to true to completely hide the command from the help extension's command listings signature String A string representing the arguments for the command, automatically-generated from the command's arguments by default Additionally, the following functions are available - please note that functions marked with are required and must be called in order to properly register a command. Name Description action A DSL function allowing you to define the code that will be run when the command is invoked, either as a lambda or by passing a function reference check Define one or more checks for this command - see the Checks page for more information requirePermissions If your command requires the bot to have some permissions, specify them here and an error will be returned then the command is run when the bot doesn't have all of those permissions Command context \u00b6 A MessageCommandContext object is a light wrapper around the command invocation, and it exists only for the duration of your command's action . It exists to provide a little extra context and functionality for your command body MessageCommandContext objects expose the following properties. Name Type Description argList Array <String> A simple array of string arguments that were passed to this command invocation argString String String representing the command invocation's arguments, exactly how they were sent on Discord arguments T Arguments object containing the command's parsed arguments, as described below breadcrumbs MutableList <Breadcrumb> List of Sentry breadcrumbs, for the Sentry intgration channel MessageChannelBehavior The message channel this command happened in command Command Current command being invoked - note that this is a generic type, and you'll need to cast it to MessageCommand commandName String Name of the current command being invoked, as provided by the user and lower-cased (meaning that this will be an alias if the user called the command that way) event MessageCreateEvent MessageCreateEvent that is responsible for causing this command invocation guild Guild? The guild this command happened in, if any member Member? Guild member responsible for executing this command, if it happened in a guild and the user wasn't actually a webhook message Message Message object from the event user User? User responsible for executing this command, if the user wasn't actually a webhook Additionally, MessageCommandContext objects expose the following functions. Name Description breadcrumb Convenience function to create and add a Sentry breadcrumb, for the Sentry intgration . getLocale Resolve and return the locale for this command context sendHelp Attempts to respond with command help using the loaded help extension, returning false if no such extension is loaded. Help extensions implement the HelpProvider interface. Message.respondTranslated Given a translation key, replies using Message.respond with the translated string, according to the resolved locale and the extension's translation bundle translate Given a translation key, returns the translated string, according to the resolved locale and the extension's translation bundle Command arguments \u00b6 Kord Extensions provides an object-based approach to argument parsing, using a base Arguments type and delegation to extension functions. Defining the arguments for your command is fairly simple: 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" , \"Post title\" ) // Single required Discord user argument val author by user ( \"author\" , \"User that this post should be attributed to\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" , \"Text content to be placed within the posts's body\" ) } We recommend writing this as an inner class, but it's up to you where you put it (as long as it's public). Once you've created your argument class, you can start using it in your commands: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 command ( :: PostArguments ) { name = \"post\" description = \"Create a post\" action { // Option 1 message . respond ( \"** ${ arguments . title } ** (by ${ arguments . author . mention } )\\n\\n\" + arguments . body ) // Option 2 with ( arguments ) { message . respond ( \"** $ title ** (by ${ author . mention } )\\n\\n\" + body ) } } } The argument parser will validate the command arguments for you automatically - if there's a problem, a CommandException will be thrown. These exceptions are automatically handled by the bot, and will be returned to whoever invoked the command to let them know what exactly went wrong. For more information on how exactly this parsing works (and how to customize it), please see the Converters page . Command groups \u00b6 For ease of use, we also provide a special type of command that includes the ability to nest commands within it. Grouped commands work just like regular commands, but with a few differences: Grouped commands have a default action that informs the user of the available subcommands, which means you don't have to define an action unless you want to override this behaviour Grouped commands have their own command and group functions that can be used for nesting Checks are tested while traversing the tree, which means that a parent's checks must pass for a subcommand to execute The help extension also fully supports subcommands, and understands what you meant if you try to request help for a subcommand - just provide the full command, and you're good to go. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 group { name = \"sport\" description = \"Set your favourite sport!\" command { name = \"basketball\" description = \"Set your favourite sport to basketball\" action { message . respond ( \"Your favourite sport is now basketball.\" ) } } command { name = \"football\" description = \"Set your favourite sport to football\" action { message . respond ( \"Your favourite sport is now football.\" ) } } group { name = \"craft\" description = \"Sports are boring, pick a craft instead!\" command { name = \"knitting\" description = \"Set your favourite sport to knitting\" action { message . respond ( \"Your favourite sport is now knitting.\" ) } } command { name = \"painting\" description = \"Set your favourite sport to painting\" action { message . respond ( \"Your favourite sport is now painting.\" ) } } } } Command parsing \u00b6 While not everyone will need to understand precisely how commands are parsed under the hood, it's worth exploring some specifics - you'll need to understand how to specify arguments on Discord, and your users will likewise need an understanding of this. Kord Extensions supports two ways to supply arguments out of the box: Positional arguments, and keyword arguments. You can mix both approaches; arguments will always be parsed in the order they're defined in the Arguments subclass, but keyword arguments can appear anywhere in the command (aside from inside another argument). Positional arguments are always parsed in order. Not Implemented: Flags Occasionally, a user will ask us why our parser doesn't support Unix-style flags - for example, --argument or -a value . The primary reason for this is that the current argument parser is already fairly complex, and supporting flags within it would massively increase the maintenance burden it already carries. Additionally, while developers and Linux users will be very familiar with flags, we don't feel that most users will find them as simple to understand as our current keyword arguments. That said, you're always free to subclass the ArgumentParser class and implement your own parsing - if you do anything interesting with this, please let us know! Additionally, single arguments can contain spaces if you \"surround them in quotes\" . As an example, take the following command: 1 2 3 4 5 !post author=109040264529608704 \"This is my title\" **My Post** This is part of the body of my post, despite being a couple lines down. Arguments can happily contain newlines - although arguments can't be *separated* using newlines, so be careful! Assuming a command prefix of ! : Our command is named post Next, a keyword argument referring to author is found, and a reference is stored title is parsed first, into the string \"This is my title\" Next, author is parsed - the bot will search for a user with the given ID, but a mention or user#discrim string can also be provided instead Finally, body is parsed - it's a coalescing string converter, so it consumes the rest of the arguments This is a fairly simple example, and you can write some fairly complicated command handling if you feel so inclined. Consuming multiple arguments Multi and coalescing converters consume arguments until they come across something they can no longer consume - for example, the numberList extension function returns a MultiConverter that consumes whole numbers until it no longer can. It will consume numbers from its starting argument onwards, until it encounters something that isn't a number. At that point, it stops and tells the argument parser how many arguments have been consumed, and processing continues to the next converter. Extensible converters Converters themselves are quite extensible, and you shouldn't be afraid to write custom converters for types that are unique to your bot. Additionally, the order of the arguments defined in your Arguments subclass will be matched by the parser, so it is technically possible to create a converter that, for example, takes a lambda that relies on the value of a previously specified argument. Custom command types \u00b6 Kord Extensions provides three command types ( MessageCommand , MessageGroupCommand and MessageSubCommand ), which should be fairly self-explanatory. You can also create your own command types by subclassing MessageCommand and overriding different properties and functions. We also support Discord's slash commands - you can read about them in a later section on this page. Some properties you may be interested in include: Name Type Description body MessageCommandContext <T>.() The command body, normally set using the action function checkList MutableList <MessageCreateEvent -> Boolean> A list of check predicates required for command execution parser ArgumentParser Class in charge of handling argument parsing, which you can override if you'd like to change how that works The following functions may also be interesting for subclasses: Name Description runChecks Function in charge of running all the checks and reporting its success call Function called to handle the actual command invocation - a lot of things happen here, you'll want to read the source before overriding this As the command system is still constantly evolving, you'll want to keep up with releases and double-check for breakages in your custom command types. Despite this maintenance burden, custom command types have a lot of uses - so feel free to experiment! Slash commands \u00b6 At some point, Discord came up with the idea of integrating slash commands with the Discord client. Kord Extensions supports slash commands as well, via the slashCommand function and SlashCommand class. Usage is very similar to the message-based commands above, with a few notable changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 slashCommand ( :: PostArguments ) { name = \"post\" description = \"Commands for working with posts\" subCommand ( :: GetArguments ) { name = \"get\" description = \"Get a post by title\" action { val post = getPostByTitle ( arguments . title ) followUp { content = \"** ${ post . title } ** (by ${ post . author . mention } )\\n\\n\" + post . body } } } subCommand ( :: CreateArguments ) { name = \"create\" description = \"Create a new post\" action { followUp { content = \"** ${ arguments . title } ** (by ${ arguments . author . mention } )\\n\\n\" + arguments . body } } } } Slash commands support the following options. They can be set directly within the slashCommand lambda - please note that the properties marked with are required and must be set in order to properly register a command. Name Type Description autoAck AutoAckType Whether to automatically ack with an ephemeral ( EPHEMERAL ) or public ( PUBLIC ) acknowledgement, or none at all ( NONE ) if you want to do it yourself name String The primary name of the command, which must be unique throughout the bot and is used for invocation description String A description for this command, which will be shown to users on Discord Command groups and subcommands Subcommands (whether inside a command group or directly within a slash command) work just like regular slash commands do, with the following caveats: Subcommands may not be guild-limited, and setting the guild property will result in an error. Instead, you'll have to limit the root command, and all subcommands will be similarly limited. Subcommands run the root command's checks first, if any - both the root command's checks and the subcommand's checks must pass for the command to be run. You may only have 25 command groups (with a max of 25 subcommands per group) per command. If you're using top-level subcommands, each slash command may only have 25 of those. On a top-level command, you may only have an action, some command groups, or some subcommands. Providing more than one of these will result in an error - exactly one must always be provided. Additionally, subcommands may not have their own subcommands or command groups. Additionally, the following functions are available. Please note that all slash commands require at least one call to either action , group or subcommand , but you may only pick one - these options are mutually exclusive. Name Description action A DSL function allowing you to define the code that will be run when the command is invoked, either as a lambda or by passing a function reference check A function allowing you to define one or more checks for this command - see the Checks page for more information group A function allowing you to create a named subcommand group that will be shown on Discord. Just like slash commands, command groups require you to set a description - don't forget to! guild A function allowing you to specify a specific guild for this command to be restricted to, if you don't want it to be registered globally subCommand A function allowing you to create a subcommand, either directly within the top-level command or within a command group. If your slash command has no arguments, simply omit the argument builder parameter. Slash commands and response types Slash commands are quite beta, at least as far as Discord is concerned. There are some strange behaviours that are difficult to understand, so we've done our best to make sure things work as intuitively as we can. When you create a slash command and set the autoAckType , you're expected to use the corresponding followUp function when sending responses to your slash command. If you're using an ephemeral style for your reponses, remember that you can (often) send a normal message if you want to show something in public. Until Discord makes things work more sensibly, we will not be supporting the response API. If you need to use this in the meantime, you can set the autoAckType to NONE and make use of Kord's interaction API that's exposed on the event object directly.","title":"Commands"},{"location":"concepts/commands/#commands","text":"If you want your bot to interact with users in a more complex manner than simply reacting to events, then you'll probably want to write some commands. Kord Extensions provides a robust and flexible commands system, built around a custom argument parsing solution that allows you to specify the arguments for your command in an entirely type-safe manner. We support both standalone and grouped commands, and you can even create your own specialised command types if you wish. That said, it's usually best to start with the basics.","title":"Commands"},{"location":"concepts/commands/#the-basics","text":"Commands provide a way for you to specify a set of actions the bot can take on a user's behalf, specified using a prefixed message in a Discord channel or private message. Creating one is simple - just use the command function in your extension's setup function. 1 2 3 4 5 6 7 8 9 10 11 12 command { // this: Command name = \"ping\" // Command name (can be a translation key) aliases = arrayOf ( \"pong\" ) // Alternate command names (can be translation keys) description = \"Returns 'Pong!'\" // Help text for the help command (can be a translation key) check { event -> true } // Return `false` to prevent the action check ( :: returnTrue ) // You can also pass it a function action { // this: MessageCommandContext message . respond ( \"Pong!\" ) } } Use the check function to define a set of predicates that must all return true in order for the command's action to be run - you can read more about checks on the Checks page . If all the checks pass, the action lambda will be called. Note that the action lambda above is a receiver function, where this is bound to a MessageCommandContext object.","title":"The basics"},{"location":"concepts/commands/#options","text":"Commands have quite a lot of options that you may be interested in while setting one up. The following properties are available right in the command lambda - please note that properties marked with are required and must be set in order to properly register a command. Name Type Description name String The primary name of the command, which must be unique throughout the bot and is used for invocation aliases Array <String> An array of secondary names to use for this command, which are also used for invocation and help commands aliasKey String? Instead of a list of aliases, you can provide a translation key here - this should refer to a comma-separated list of aliases in your translations description String A long description used by the help extension to describe the command - the first line of which should be a short summary enabled Boolean Defaulting to true , this can be set programmatically in order to entirely disable or re-enable the command hidden Boolean Default to false , this can be set to true to completely hide the command from the help extension's command listings signature String A string representing the arguments for the command, automatically-generated from the command's arguments by default Additionally, the following functions are available - please note that functions marked with are required and must be called in order to properly register a command. Name Description action A DSL function allowing you to define the code that will be run when the command is invoked, either as a lambda or by passing a function reference check Define one or more checks for this command - see the Checks page for more information requirePermissions If your command requires the bot to have some permissions, specify them here and an error will be returned then the command is run when the bot doesn't have all of those permissions","title":"Options"},{"location":"concepts/commands/#command-context","text":"A MessageCommandContext object is a light wrapper around the command invocation, and it exists only for the duration of your command's action . It exists to provide a little extra context and functionality for your command body MessageCommandContext objects expose the following properties. Name Type Description argList Array <String> A simple array of string arguments that were passed to this command invocation argString String String representing the command invocation's arguments, exactly how they were sent on Discord arguments T Arguments object containing the command's parsed arguments, as described below breadcrumbs MutableList <Breadcrumb> List of Sentry breadcrumbs, for the Sentry intgration channel MessageChannelBehavior The message channel this command happened in command Command Current command being invoked - note that this is a generic type, and you'll need to cast it to MessageCommand commandName String Name of the current command being invoked, as provided by the user and lower-cased (meaning that this will be an alias if the user called the command that way) event MessageCreateEvent MessageCreateEvent that is responsible for causing this command invocation guild Guild? The guild this command happened in, if any member Member? Guild member responsible for executing this command, if it happened in a guild and the user wasn't actually a webhook message Message Message object from the event user User? User responsible for executing this command, if the user wasn't actually a webhook Additionally, MessageCommandContext objects expose the following functions. Name Description breadcrumb Convenience function to create and add a Sentry breadcrumb, for the Sentry intgration . getLocale Resolve and return the locale for this command context sendHelp Attempts to respond with command help using the loaded help extension, returning false if no such extension is loaded. Help extensions implement the HelpProvider interface. Message.respondTranslated Given a translation key, replies using Message.respond with the translated string, according to the resolved locale and the extension's translation bundle translate Given a translation key, returns the translated string, according to the resolved locale and the extension's translation bundle","title":"Command context"},{"location":"concepts/commands/#command-arguments","text":"Kord Extensions provides an object-based approach to argument parsing, using a base Arguments type and delegation to extension functions. Defining the arguments for your command is fairly simple: 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" , \"Post title\" ) // Single required Discord user argument val author by user ( \"author\" , \"User that this post should be attributed to\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" , \"Text content to be placed within the posts's body\" ) } We recommend writing this as an inner class, but it's up to you where you put it (as long as it's public). Once you've created your argument class, you can start using it in your commands: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 command ( :: PostArguments ) { name = \"post\" description = \"Create a post\" action { // Option 1 message . respond ( \"** ${ arguments . title } ** (by ${ arguments . author . mention } )\\n\\n\" + arguments . body ) // Option 2 with ( arguments ) { message . respond ( \"** $ title ** (by ${ author . mention } )\\n\\n\" + body ) } } } The argument parser will validate the command arguments for you automatically - if there's a problem, a CommandException will be thrown. These exceptions are automatically handled by the bot, and will be returned to whoever invoked the command to let them know what exactly went wrong. For more information on how exactly this parsing works (and how to customize it), please see the Converters page .","title":"Command arguments"},{"location":"concepts/commands/#command-groups","text":"For ease of use, we also provide a special type of command that includes the ability to nest commands within it. Grouped commands work just like regular commands, but with a few differences: Grouped commands have a default action that informs the user of the available subcommands, which means you don't have to define an action unless you want to override this behaviour Grouped commands have their own command and group functions that can be used for nesting Checks are tested while traversing the tree, which means that a parent's checks must pass for a subcommand to execute The help extension also fully supports subcommands, and understands what you meant if you try to request help for a subcommand - just provide the full command, and you're good to go. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 group { name = \"sport\" description = \"Set your favourite sport!\" command { name = \"basketball\" description = \"Set your favourite sport to basketball\" action { message . respond ( \"Your favourite sport is now basketball.\" ) } } command { name = \"football\" description = \"Set your favourite sport to football\" action { message . respond ( \"Your favourite sport is now football.\" ) } } group { name = \"craft\" description = \"Sports are boring, pick a craft instead!\" command { name = \"knitting\" description = \"Set your favourite sport to knitting\" action { message . respond ( \"Your favourite sport is now knitting.\" ) } } command { name = \"painting\" description = \"Set your favourite sport to painting\" action { message . respond ( \"Your favourite sport is now painting.\" ) } } } }","title":"Command groups"},{"location":"concepts/commands/#command-parsing","text":"While not everyone will need to understand precisely how commands are parsed under the hood, it's worth exploring some specifics - you'll need to understand how to specify arguments on Discord, and your users will likewise need an understanding of this. Kord Extensions supports two ways to supply arguments out of the box: Positional arguments, and keyword arguments. You can mix both approaches; arguments will always be parsed in the order they're defined in the Arguments subclass, but keyword arguments can appear anywhere in the command (aside from inside another argument). Positional arguments are always parsed in order. Not Implemented: Flags Occasionally, a user will ask us why our parser doesn't support Unix-style flags - for example, --argument or -a value . The primary reason for this is that the current argument parser is already fairly complex, and supporting flags within it would massively increase the maintenance burden it already carries. Additionally, while developers and Linux users will be very familiar with flags, we don't feel that most users will find them as simple to understand as our current keyword arguments. That said, you're always free to subclass the ArgumentParser class and implement your own parsing - if you do anything interesting with this, please let us know! Additionally, single arguments can contain spaces if you \"surround them in quotes\" . As an example, take the following command: 1 2 3 4 5 !post author=109040264529608704 \"This is my title\" **My Post** This is part of the body of my post, despite being a couple lines down. Arguments can happily contain newlines - although arguments can't be *separated* using newlines, so be careful! Assuming a command prefix of ! : Our command is named post Next, a keyword argument referring to author is found, and a reference is stored title is parsed first, into the string \"This is my title\" Next, author is parsed - the bot will search for a user with the given ID, but a mention or user#discrim string can also be provided instead Finally, body is parsed - it's a coalescing string converter, so it consumes the rest of the arguments This is a fairly simple example, and you can write some fairly complicated command handling if you feel so inclined. Consuming multiple arguments Multi and coalescing converters consume arguments until they come across something they can no longer consume - for example, the numberList extension function returns a MultiConverter that consumes whole numbers until it no longer can. It will consume numbers from its starting argument onwards, until it encounters something that isn't a number. At that point, it stops and tells the argument parser how many arguments have been consumed, and processing continues to the next converter. Extensible converters Converters themselves are quite extensible, and you shouldn't be afraid to write custom converters for types that are unique to your bot. Additionally, the order of the arguments defined in your Arguments subclass will be matched by the parser, so it is technically possible to create a converter that, for example, takes a lambda that relies on the value of a previously specified argument.","title":"Command parsing"},{"location":"concepts/commands/#custom-command-types","text":"Kord Extensions provides three command types ( MessageCommand , MessageGroupCommand and MessageSubCommand ), which should be fairly self-explanatory. You can also create your own command types by subclassing MessageCommand and overriding different properties and functions. We also support Discord's slash commands - you can read about them in a later section on this page. Some properties you may be interested in include: Name Type Description body MessageCommandContext <T>.() The command body, normally set using the action function checkList MutableList <MessageCreateEvent -> Boolean> A list of check predicates required for command execution parser ArgumentParser Class in charge of handling argument parsing, which you can override if you'd like to change how that works The following functions may also be interesting for subclasses: Name Description runChecks Function in charge of running all the checks and reporting its success call Function called to handle the actual command invocation - a lot of things happen here, you'll want to read the source before overriding this As the command system is still constantly evolving, you'll want to keep up with releases and double-check for breakages in your custom command types. Despite this maintenance burden, custom command types have a lot of uses - so feel free to experiment!","title":"Custom command types"},{"location":"concepts/commands/#slash-commands","text":"At some point, Discord came up with the idea of integrating slash commands with the Discord client. Kord Extensions supports slash commands as well, via the slashCommand function and SlashCommand class. Usage is very similar to the message-based commands above, with a few notable changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 slashCommand ( :: PostArguments ) { name = \"post\" description = \"Commands for working with posts\" subCommand ( :: GetArguments ) { name = \"get\" description = \"Get a post by title\" action { val post = getPostByTitle ( arguments . title ) followUp { content = \"** ${ post . title } ** (by ${ post . author . mention } )\\n\\n\" + post . body } } } subCommand ( :: CreateArguments ) { name = \"create\" description = \"Create a new post\" action { followUp { content = \"** ${ arguments . title } ** (by ${ arguments . author . mention } )\\n\\n\" + arguments . body } } } } Slash commands support the following options. They can be set directly within the slashCommand lambda - please note that the properties marked with are required and must be set in order to properly register a command. Name Type Description autoAck AutoAckType Whether to automatically ack with an ephemeral ( EPHEMERAL ) or public ( PUBLIC ) acknowledgement, or none at all ( NONE ) if you want to do it yourself name String The primary name of the command, which must be unique throughout the bot and is used for invocation description String A description for this command, which will be shown to users on Discord Command groups and subcommands Subcommands (whether inside a command group or directly within a slash command) work just like regular slash commands do, with the following caveats: Subcommands may not be guild-limited, and setting the guild property will result in an error. Instead, you'll have to limit the root command, and all subcommands will be similarly limited. Subcommands run the root command's checks first, if any - both the root command's checks and the subcommand's checks must pass for the command to be run. You may only have 25 command groups (with a max of 25 subcommands per group) per command. If you're using top-level subcommands, each slash command may only have 25 of those. On a top-level command, you may only have an action, some command groups, or some subcommands. Providing more than one of these will result in an error - exactly one must always be provided. Additionally, subcommands may not have their own subcommands or command groups. Additionally, the following functions are available. Please note that all slash commands require at least one call to either action , group or subcommand , but you may only pick one - these options are mutually exclusive. Name Description action A DSL function allowing you to define the code that will be run when the command is invoked, either as a lambda or by passing a function reference check A function allowing you to define one or more checks for this command - see the Checks page for more information group A function allowing you to create a named subcommand group that will be shown on Discord. Just like slash commands, command groups require you to set a description - don't forget to! guild A function allowing you to specify a specific guild for this command to be restricted to, if you don't want it to be registered globally subCommand A function allowing you to create a subcommand, either directly within the top-level command or within a command group. If your slash command has no arguments, simply omit the argument builder parameter. Slash commands and response types Slash commands are quite beta, at least as far as Discord is concerned. There are some strange behaviours that are difficult to understand, so we've done our best to make sure things work as intuitively as we can. When you create a slash command and set the autoAckType , you're expected to use the corresponding followUp function when sending responses to your slash command. If you're using an ephemeral style for your reponses, remember that you can (often) send a normal message if you want to show something in public. Until Discord makes things work more sensibly, we will not be supporting the response API. If you need to use this in the meantime, you can set the autoAckType to NONE and make use of Kord's interaction API that's exposed on the event object directly.","title":"Slash commands"},{"location":"concepts/converters/","text":"Converters \u00b6 Converters are small classes that exist to convert strings - or groups of strings - into other types. They make up the core of the argument parsing provided with Kord Extensions, allowing you to easily parse command arguments into complex types with no compiler plugins, generated Kotlin or reflection whatsoever. Converter types \u00b6 In the interests of making sure you never get a type you're not expecting, Kord Extensions ships with a wide variety of converters. Converters are first classified by the way they behave, and then by the type they exist to convert to. The basic converter types are as follows: Type Description ChoiceConverter A slash command-specific converter which includes a set of up to ten options that the user can pick from - this type of converter is not supported by normal message commands CoalescingConverter A converter representing a required argument converted from a list of strings, combined into a single value DefaultingConverter A converter representing a single argument with a default value, converted from up to one supplied string MultiConverter A converter representing an argument converted from a list of strings, one value per string - which may be either required or optional - this type of converter is not supported by slash commands OptionalConverter A converter representing a single, optional/nullable argument converted from up to one supplied string, with an optional outputError property that will fail the parse and return an error if there was a problem during parsing SingleConverter A converter representing a single, required argument converted from exactly one supplied string There are also some compound converters, which combine the behaviours found in other converters, such as: DefaultingCoalescingConverter OptionalCoalescingConverter We also provide some special implementations that wrap other converters, such as: CoalescingToDefaultingConverter (obtained via CoalescingConverter#toDefaulting() ) CoalescingToOptionalConverter (obtained via CoalescingConverter#toOptional() ) SingleToDefaultingConverter (obtained via SingleConverter#toDefaulting() ) SingleToMultiConverter (obtained via SingleConverter#toMulti() ) SingleToOptionalConverter (obtained via SingleConverter#toOptional() ) We recommend exploring the source code for these converters, as we're likely to continue adding them. Bundled converters \u00b6 Converters are provided that support the following type conversions, out of the box: Boolean Channel Decimal (Doubles only) Email Emoji (Server emoji on Discord) Enum (Any enums you like, including those you define yourself) Guild Member Message Number (Longs only) Regex (Kotlin wrapper type only) with special-casing for coalescing conversion Role String with special-casing for coalescing conversion Snowflake User Additional modules are available that add more converters: Java Time : * Duration (Java Time) with special-casing for coalescing conversion Time4J : * Duration (Time4J) with special-casing for coalescing conversion Usage \u00b6 Converters are intended to be used as part of your commands setup, via the Arguments object. Arguments is a special type that contains a list of each of the delegated properties in your class, in order - placed there by specially-created extension functions that create converters for you. Here's an example, from the Commands page . 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" , \"Post title\" ) // Single required Discord user argument val author by user ( \"author\" , \"User that this post should be attributed to\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" , \"Text content to be placed within the posts's body\" ) } In this example, we have three arguments: title - a required String argument, with the friendly name of \"title\" and a human-readable description author - a required Discord User argument, with the friendly name of \"author\" and a human-readable description body - A required coalescing String argument, with the friendly name of \"body\" and a human-readable description All arguments require a friendly name, and a human-readable description. The name will be used to refer to that argument in the command's signature, as well as error and other help messages. It's also the name that will be used for keyword arguments. The description will be used by the help extension to explain what each argument is for, and will be displayed directly on Discord when you're working with slash commands. Try to keep it short, but descriptive! On top of this, different converters (and types of converters) may take extra arguments. For example, all defaulting converters require you to pass a default value to their creation function, while optional converters do not take a default value and instead will return null by default. Finding converter functions As of this writing, there are over 1,100 lines covering Arguments object extension functions. While you can read the source for a full list, we recommend making use of your IDE's auto-completion functionality for discovery - especially if you've written custom converters, or you're making use of third-party converters. Validators \u00b6 All converters support validators. Validators allow you to specify a simple lambda that acts on the parsed result, and throws a CommandException if something is wrong - which will be sent to the user. Validators are receiver functions for Argument<*> objects, so both displayName and description are available. For example... 1 2 3 4 5 6 7 8 9 10 11 12 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" , \"Post title\" ) { if ( it . length > 30 ) throw CommandError ( \"` $ displayName ` must be 30 characters at most\" ) } // Single required Discord user argument val author by user ( \"author\" , \"User that this post should be attributed to\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" , \"Text content to be placed within the posts's body\" ) } Slash commands and converters \u00b6 While slash commands make use of all the usual converter types, the following points are worth bearing in mind: Multi converters are not supported by slash commands - Discord has provided no way to provide a list of parameters for a single argument, and any additional parsing we do to try to achieve that is likely to be confusing or difficult to use, let alone brittle. There are additional ChoiceConverter -based converters for numbers and strings available. These converters are only supported for slash commands , and will not work with the usual message-based commands. As Discord does not provide a rich array of types for their commands, many converters will be shown as string arguments within the Discord client. Your argument descriptions should be up-front about what the argument is meant to be, and how it works. Custom converters \u00b6 If you'd like to convert arguments to a type that we don't currently support, or you'd like to add some extra validation to arguments, then custom converters are the way to go. Depending on what you're doing, you'll want to start by subclassing one of the following converter base classes: SingleConverter for single converters, which can be wrapped into defaulting, multi and optional converters CoalescingConverter for coalescing converters, which can be wrapped into defaulting and optional variants When creating your converter, one of the biggest things you can do to help yourself is to read over the source for the base classes and bundled converters. Custom converters can be a little tricky to get your head around at first, so feel free to join the Kotlin Discord server if you need to ask questions. How do I bail when something goes wrong? As you may expect, errors are handled using Kotlin's exceptions system. Exceptions can be thrown as normal, and they'll be caught by the argument parser and transformed into an error message. However, you may wish to provide a more useful error message to the user - for these cases, you should create and throw an instance of CommandException yourself. The message passed to CommandException will be returned to the user verbatim, so make it descriptive! When writing a CoalescingConverter subclass, your converter is expected to check the shouldThrow property. If this property is true , then you should throw a CommandException when your converter fails to parse a value, explaining what exactly went wrong in the exception's description. Remember that your end users are not necessarily developers! Most people will not understand a technical description or a default exception message - any CommandException instances you throw should contain a human-readable error message that tells the user what went wrong so that they can correct their command invocation and try again. If you need to provide developer-oriented feedback, use a logger! Because of this, only CommandException instances will be returned to the user verbatim. All other exception types will be logged, and a generic error message will be returned to the user. Parsing expectations The Kord Extension parsing system uses a token-based parser under the hood. There are some expectations to bear in mind when writing a converter, to ensure that it behaves in a manner that's consistent with the rest of the framework. Take values from named instead of taking tokens from the parser, where named isn't null . For example: Single converters: 1 val arg : String = named ?: parser ?. parseNext () ?. data ?: return false Coalescing converters: 1 val args : String = namedArgument ?. joinToString ( \" \" ) ?: parser ?. consumeRemaining () ?: return 0 List-based converters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 val args = namedArguments ?: parser ?. run { val tokens : MutableList < String > = mutableListOf () while ( hasNext ) { val nextToken = peekNext () if ( nextToken !! . data . all { isValid ( it ) }) { tokens . add ( parseNext () !! . data ) } else { break } } tokens } ?: return 0 For optional/defaulting converters, Use peek functions to validate based on what's coming without consuming the token, and use parseNext() only when you're satisfied you can consume the token. This means that the token won't be consumed when you can't handle it, which means that parsing can move to the next converter, as expected. For more advanced use-cases, you can always make use of the other properties and functions present on the parser object. It's impossible for a framework to completely cover every possible use-case, so providing direct access to the parser (and its cursor) was a must. Once you've created your converters, we recommend writing Arguments extension functions for them. As before, we heavily recommend reading the source for the extension functions that already exist - they're quite simple, but it always pays to try to write the best APIs you can, especially if you expect someone else to make use of your code someday! When writing your extension functions, you'll need to make use of some restricted converter functions. We recommend placing the following statement at the top of the file that defines these extension functions, to make your life easier. 1 2 3 4 5 6 @file : OptIn ( KordPreview :: class , ConverterToDefaulting :: class , ConverterToMulti :: class , ConverterToOptional :: class ) This will allow you to use the toDefaulting , toMulti and toOptional functions that will return wrapped versions of the converter they're being called against. Please note that users should never make use of these functions as they may cause all kinds of strange issues - provide wrapping extension functions instead! Generated converter functions \u00b6 KSP is in beta! The Kord Extensions annotation processor is written using Google's Kolin Symbol Processing API . This project is considered to be in an early beta and, while we are using it to generate converter functions as part of Kord Extensions, you should beware of unexpected issues. For the sake of convenience, you can make use of an annotation processor to generate your converter functions. This will automatically generate converter functions for annotated converters, matching a (fairly specific) standard specification. This system isn't suitable for use by every converter, but most types should be very suitable for use with it. Gradle setup \u00b6 First, you'll need to set up your gradle project. You'll need to add Google's KSP plugin, as well as the KordEx annotation processor. settings.gradle.kts 1 2 3 4 5 6 7 8 9 10 pluginManagement { repositories { google () // Google's KSP plugin is still beta gradlePluginPortal () } } plugins { id ( \"com.google.devtools.ksp\" ) version \"1.5.10-1.0.0-beta02\" } build.gradle.kts 1 2 3 4 5 6 7 plugins { id ( \"com.google.devtools.ksp\" ) } dependencies { ksp ( \"com.kotlindiscord.kord.extensions:annotation-processor: $ kordexVersion \" ) } Converter annotation \u00b6 To start with, write your converters as you always do. Once you're happy with your converters, you can apply the @Converter annotation to configure its code generation. Properties marked with are required. Converter type restrictions Some converter types are not compatible with each other. Specifically, you can't specify the following types together: COALESCING with CHOICE LIST with COALESCING or CHOICE These converter types cannot work togther, and the annotation process will throw an exception if you specify them together. Additionally, please note that the COALESCING and CHOICE converter types will affect the generation of all converter functions - specifying COALESCING with DEFAULTING will, for example, create a coalescing, defaulting converter function. Specify SINGLE to generate a function without any additional modifiers. You can specify any number of compatible types together - SINGLE , DEFAULTING , LIST and OPTIONAL together will, for example, generate four converter functions - one for each. Parameter Type Description name String The base name of your converter functions - string or int for example types Array <ConverterType> A list of converter function types to generate - there are some restrictions, which you can find in the warning above this table imports Array<String> A list of extra imports that must be present in the generated file - without the preceeding import keyword arguments Array<String> A list of extra arguments that will be added to all generated functions, without the trailing commas - these will also be passed into the converter class invocation as matching named arguments, so your converter's constructor must have the same names generic String A single generic typevar of the form NAME : Type that will be applied to all generated functions - typevars will be marked reified and the functions will be marked inline , so you may need to add noinline or crossinline modifiers to any callable arguments you supply to the arguments array As an example, let's apply this annotation to the built-in enum converter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Converter ( name = \"enum\" , types = [ ConverterType . SINGLE ] , generic = \"E: Enum<E>\" , imports = [ \"com.kotlindiscord.kord.extensions.commands.converters.impl.getEnum\" ] , arguments = [ \"typeName: String\" , \"noinline getter: suspend (String) -> E? = { getEnum<E>(it) }\" ] ) public class EnumConverter < E : Enum < E >> ( typeName : String , private val getter : suspend ( String ) -> E?, override var validator : Validator < E > = null ) : SingleConverter < E > () { // ... } public inline fun < reified E : Enum < E > > getEnum ( arg : String ): E? = enumValues < E > (). firstOrNull { it . name . equals ( arg , true ) } This will generate the following function when you next build your project. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Creates a enum converter, for single arguments. * * @see EnumConverter */ public inline fun < reified E : Enum < E > > Arguments . enum ( displayName : String , // All converters need this argument description : String , // All converters need this argument typeName : String , noinline getter : suspend ( String ) -> E? = { getEnum < E > ( it ) }, noinline validator : Validator < E > = null , // All converters need this argument ): SingleConverter < E > = arg ( displayName = displayName , description = description , converter = EnumConverter ( validator = validator , typeName = typeName , getter = getter , ) ) IDE support \u00b6 Once you've finished annotating your converters, build your project. KSP will output the generated sources to build/generated/ksp/main/kotlin - but your IDE will not be aware of these generated sources by default. In IntelliJ IDEA, you can solve this problem by updating the project settings for your module. Click to enlarge Find your module's main source set Click Add Content Root and add build/generated/ksp/ Find the main/kotlin folder, right-click it and mark it as a sources root Click Apply and OK Locate build/generated/ksp/main/kotlin in your project's file tree, right-click it, go to Mark as and select Generated sources root Once you've done this, IDEA should properly resolve your generated converter functions as normal. Please note, however, that anything that removes your build folder (or specifically build/generated/kotlin ) will break your project settings , and you'll have to re-add the content root.","title":"Converters"},{"location":"concepts/converters/#converters","text":"Converters are small classes that exist to convert strings - or groups of strings - into other types. They make up the core of the argument parsing provided with Kord Extensions, allowing you to easily parse command arguments into complex types with no compiler plugins, generated Kotlin or reflection whatsoever.","title":"Converters"},{"location":"concepts/converters/#converter-types","text":"In the interests of making sure you never get a type you're not expecting, Kord Extensions ships with a wide variety of converters. Converters are first classified by the way they behave, and then by the type they exist to convert to. The basic converter types are as follows: Type Description ChoiceConverter A slash command-specific converter which includes a set of up to ten options that the user can pick from - this type of converter is not supported by normal message commands CoalescingConverter A converter representing a required argument converted from a list of strings, combined into a single value DefaultingConverter A converter representing a single argument with a default value, converted from up to one supplied string MultiConverter A converter representing an argument converted from a list of strings, one value per string - which may be either required or optional - this type of converter is not supported by slash commands OptionalConverter A converter representing a single, optional/nullable argument converted from up to one supplied string, with an optional outputError property that will fail the parse and return an error if there was a problem during parsing SingleConverter A converter representing a single, required argument converted from exactly one supplied string There are also some compound converters, which combine the behaviours found in other converters, such as: DefaultingCoalescingConverter OptionalCoalescingConverter We also provide some special implementations that wrap other converters, such as: CoalescingToDefaultingConverter (obtained via CoalescingConverter#toDefaulting() ) CoalescingToOptionalConverter (obtained via CoalescingConverter#toOptional() ) SingleToDefaultingConverter (obtained via SingleConverter#toDefaulting() ) SingleToMultiConverter (obtained via SingleConverter#toMulti() ) SingleToOptionalConverter (obtained via SingleConverter#toOptional() ) We recommend exploring the source code for these converters, as we're likely to continue adding them.","title":"Converter types"},{"location":"concepts/converters/#bundled-converters","text":"Converters are provided that support the following type conversions, out of the box: Boolean Channel Decimal (Doubles only) Email Emoji (Server emoji on Discord) Enum (Any enums you like, including those you define yourself) Guild Member Message Number (Longs only) Regex (Kotlin wrapper type only) with special-casing for coalescing conversion Role String with special-casing for coalescing conversion Snowflake User Additional modules are available that add more converters: Java Time : * Duration (Java Time) with special-casing for coalescing conversion Time4J : * Duration (Time4J) with special-casing for coalescing conversion","title":"Bundled converters"},{"location":"concepts/converters/#usage","text":"Converters are intended to be used as part of your commands setup, via the Arguments object. Arguments is a special type that contains a list of each of the delegated properties in your class, in order - placed there by specially-created extension functions that create converters for you. Here's an example, from the Commands page . 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" , \"Post title\" ) // Single required Discord user argument val author by user ( \"author\" , \"User that this post should be attributed to\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" , \"Text content to be placed within the posts's body\" ) } In this example, we have three arguments: title - a required String argument, with the friendly name of \"title\" and a human-readable description author - a required Discord User argument, with the friendly name of \"author\" and a human-readable description body - A required coalescing String argument, with the friendly name of \"body\" and a human-readable description All arguments require a friendly name, and a human-readable description. The name will be used to refer to that argument in the command's signature, as well as error and other help messages. It's also the name that will be used for keyword arguments. The description will be used by the help extension to explain what each argument is for, and will be displayed directly on Discord when you're working with slash commands. Try to keep it short, but descriptive! On top of this, different converters (and types of converters) may take extra arguments. For example, all defaulting converters require you to pass a default value to their creation function, while optional converters do not take a default value and instead will return null by default. Finding converter functions As of this writing, there are over 1,100 lines covering Arguments object extension functions. While you can read the source for a full list, we recommend making use of your IDE's auto-completion functionality for discovery - especially if you've written custom converters, or you're making use of third-party converters.","title":"Usage"},{"location":"concepts/converters/#validators","text":"All converters support validators. Validators allow you to specify a simple lambda that acts on the parsed result, and throws a CommandException if something is wrong - which will be sent to the user. Validators are receiver functions for Argument<*> objects, so both displayName and description are available. For example... 1 2 3 4 5 6 7 8 9 10 11 12 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" , \"Post title\" ) { if ( it . length > 30 ) throw CommandError ( \"` $ displayName ` must be 30 characters at most\" ) } // Single required Discord user argument val author by user ( \"author\" , \"User that this post should be attributed to\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" , \"Text content to be placed within the posts's body\" ) }","title":"Validators"},{"location":"concepts/converters/#slash-commands-and-converters","text":"While slash commands make use of all the usual converter types, the following points are worth bearing in mind: Multi converters are not supported by slash commands - Discord has provided no way to provide a list of parameters for a single argument, and any additional parsing we do to try to achieve that is likely to be confusing or difficult to use, let alone brittle. There are additional ChoiceConverter -based converters for numbers and strings available. These converters are only supported for slash commands , and will not work with the usual message-based commands. As Discord does not provide a rich array of types for their commands, many converters will be shown as string arguments within the Discord client. Your argument descriptions should be up-front about what the argument is meant to be, and how it works.","title":"Slash commands and converters"},{"location":"concepts/converters/#custom-converters","text":"If you'd like to convert arguments to a type that we don't currently support, or you'd like to add some extra validation to arguments, then custom converters are the way to go. Depending on what you're doing, you'll want to start by subclassing one of the following converter base classes: SingleConverter for single converters, which can be wrapped into defaulting, multi and optional converters CoalescingConverter for coalescing converters, which can be wrapped into defaulting and optional variants When creating your converter, one of the biggest things you can do to help yourself is to read over the source for the base classes and bundled converters. Custom converters can be a little tricky to get your head around at first, so feel free to join the Kotlin Discord server if you need to ask questions. How do I bail when something goes wrong? As you may expect, errors are handled using Kotlin's exceptions system. Exceptions can be thrown as normal, and they'll be caught by the argument parser and transformed into an error message. However, you may wish to provide a more useful error message to the user - for these cases, you should create and throw an instance of CommandException yourself. The message passed to CommandException will be returned to the user verbatim, so make it descriptive! When writing a CoalescingConverter subclass, your converter is expected to check the shouldThrow property. If this property is true , then you should throw a CommandException when your converter fails to parse a value, explaining what exactly went wrong in the exception's description. Remember that your end users are not necessarily developers! Most people will not understand a technical description or a default exception message - any CommandException instances you throw should contain a human-readable error message that tells the user what went wrong so that they can correct their command invocation and try again. If you need to provide developer-oriented feedback, use a logger! Because of this, only CommandException instances will be returned to the user verbatim. All other exception types will be logged, and a generic error message will be returned to the user. Parsing expectations The Kord Extension parsing system uses a token-based parser under the hood. There are some expectations to bear in mind when writing a converter, to ensure that it behaves in a manner that's consistent with the rest of the framework. Take values from named instead of taking tokens from the parser, where named isn't null . For example: Single converters: 1 val arg : String = named ?: parser ?. parseNext () ?. data ?: return false Coalescing converters: 1 val args : String = namedArgument ?. joinToString ( \" \" ) ?: parser ?. consumeRemaining () ?: return 0 List-based converters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 val args = namedArguments ?: parser ?. run { val tokens : MutableList < String > = mutableListOf () while ( hasNext ) { val nextToken = peekNext () if ( nextToken !! . data . all { isValid ( it ) }) { tokens . add ( parseNext () !! . data ) } else { break } } tokens } ?: return 0 For optional/defaulting converters, Use peek functions to validate based on what's coming without consuming the token, and use parseNext() only when you're satisfied you can consume the token. This means that the token won't be consumed when you can't handle it, which means that parsing can move to the next converter, as expected. For more advanced use-cases, you can always make use of the other properties and functions present on the parser object. It's impossible for a framework to completely cover every possible use-case, so providing direct access to the parser (and its cursor) was a must. Once you've created your converters, we recommend writing Arguments extension functions for them. As before, we heavily recommend reading the source for the extension functions that already exist - they're quite simple, but it always pays to try to write the best APIs you can, especially if you expect someone else to make use of your code someday! When writing your extension functions, you'll need to make use of some restricted converter functions. We recommend placing the following statement at the top of the file that defines these extension functions, to make your life easier. 1 2 3 4 5 6 @file : OptIn ( KordPreview :: class , ConverterToDefaulting :: class , ConverterToMulti :: class , ConverterToOptional :: class ) This will allow you to use the toDefaulting , toMulti and toOptional functions that will return wrapped versions of the converter they're being called against. Please note that users should never make use of these functions as they may cause all kinds of strange issues - provide wrapping extension functions instead!","title":"Custom converters"},{"location":"concepts/converters/#generated-converter-functions","text":"KSP is in beta! The Kord Extensions annotation processor is written using Google's Kolin Symbol Processing API . This project is considered to be in an early beta and, while we are using it to generate converter functions as part of Kord Extensions, you should beware of unexpected issues. For the sake of convenience, you can make use of an annotation processor to generate your converter functions. This will automatically generate converter functions for annotated converters, matching a (fairly specific) standard specification. This system isn't suitable for use by every converter, but most types should be very suitable for use with it.","title":"Generated converter functions"},{"location":"concepts/converters/#gradle-setup","text":"First, you'll need to set up your gradle project. You'll need to add Google's KSP plugin, as well as the KordEx annotation processor. settings.gradle.kts 1 2 3 4 5 6 7 8 9 10 pluginManagement { repositories { google () // Google's KSP plugin is still beta gradlePluginPortal () } } plugins { id ( \"com.google.devtools.ksp\" ) version \"1.5.10-1.0.0-beta02\" } build.gradle.kts 1 2 3 4 5 6 7 plugins { id ( \"com.google.devtools.ksp\" ) } dependencies { ksp ( \"com.kotlindiscord.kord.extensions:annotation-processor: $ kordexVersion \" ) }","title":"Gradle setup"},{"location":"concepts/converters/#converter-annotation","text":"To start with, write your converters as you always do. Once you're happy with your converters, you can apply the @Converter annotation to configure its code generation. Properties marked with are required. Converter type restrictions Some converter types are not compatible with each other. Specifically, you can't specify the following types together: COALESCING with CHOICE LIST with COALESCING or CHOICE These converter types cannot work togther, and the annotation process will throw an exception if you specify them together. Additionally, please note that the COALESCING and CHOICE converter types will affect the generation of all converter functions - specifying COALESCING with DEFAULTING will, for example, create a coalescing, defaulting converter function. Specify SINGLE to generate a function without any additional modifiers. You can specify any number of compatible types together - SINGLE , DEFAULTING , LIST and OPTIONAL together will, for example, generate four converter functions - one for each. Parameter Type Description name String The base name of your converter functions - string or int for example types Array <ConverterType> A list of converter function types to generate - there are some restrictions, which you can find in the warning above this table imports Array<String> A list of extra imports that must be present in the generated file - without the preceeding import keyword arguments Array<String> A list of extra arguments that will be added to all generated functions, without the trailing commas - these will also be passed into the converter class invocation as matching named arguments, so your converter's constructor must have the same names generic String A single generic typevar of the form NAME : Type that will be applied to all generated functions - typevars will be marked reified and the functions will be marked inline , so you may need to add noinline or crossinline modifiers to any callable arguments you supply to the arguments array As an example, let's apply this annotation to the built-in enum converter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Converter ( name = \"enum\" , types = [ ConverterType . SINGLE ] , generic = \"E: Enum<E>\" , imports = [ \"com.kotlindiscord.kord.extensions.commands.converters.impl.getEnum\" ] , arguments = [ \"typeName: String\" , \"noinline getter: suspend (String) -> E? = { getEnum<E>(it) }\" ] ) public class EnumConverter < E : Enum < E >> ( typeName : String , private val getter : suspend ( String ) -> E?, override var validator : Validator < E > = null ) : SingleConverter < E > () { // ... } public inline fun < reified E : Enum < E > > getEnum ( arg : String ): E? = enumValues < E > (). firstOrNull { it . name . equals ( arg , true ) } This will generate the following function when you next build your project. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Creates a enum converter, for single arguments. * * @see EnumConverter */ public inline fun < reified E : Enum < E > > Arguments . enum ( displayName : String , // All converters need this argument description : String , // All converters need this argument typeName : String , noinline getter : suspend ( String ) -> E? = { getEnum < E > ( it ) }, noinline validator : Validator < E > = null , // All converters need this argument ): SingleConverter < E > = arg ( displayName = displayName , description = description , converter = EnumConverter ( validator = validator , typeName = typeName , getter = getter , ) )","title":"Converter annotation"},{"location":"concepts/converters/#ide-support","text":"Once you've finished annotating your converters, build your project. KSP will output the generated sources to build/generated/ksp/main/kotlin - but your IDE will not be aware of these generated sources by default. In IntelliJ IDEA, you can solve this problem by updating the project settings for your module. Click to enlarge Find your module's main source set Click Add Content Root and add build/generated/ksp/ Find the main/kotlin folder, right-click it and mark it as a sources root Click Apply and OK Locate build/generated/ksp/main/kotlin in your project's file tree, right-click it, go to Mark as and select Generated sources root Once you've done this, IDEA should properly resolve your generated converter functions as normal. Please note, however, that anything that removes your build folder (or specifically build/generated/kotlin ) will break your project settings , and you'll have to re-add the content root.","title":"IDE support"},{"location":"concepts/events/","text":"Events \u00b6 Events represent a single action, either by a user, Discord itself, or your bot. They're one of the primary ways your bot will react to things happening on Discord, and they're an absolute essential concept to grasp. Subclassing these types While the event handler and context types that are about to be described do support subclassing, we do not currently provide a way to provide your subclasses in the typical manner. If you have a use-case for this then please let us know, and we'll prioritise it! Event Handlers \u00b6 In order to react to events, you'll need to add an event handler to your extension. Event handlers represent blocks of code that will be run in response to an event, along with some associated metadata. Creating one is simple - just use the event function in your extension's setup function. 1 2 3 4 5 6 7 8 event < EventClass > { // this: EventHandler<EventClass> check { event -> true } // Return `false` to prevent the action check ( :: returnTrue ) // You can also pass it a function action { // this: EventContext // Code to run when the event is received } } Use the check function to define a set of predicates that must all return true in order for the event handler to be run - you can read more about checks on the Checks page . Once all the checks pass, the action lambda will be called. Note that the action lambda above is a receiver function, where this is bound to an EventContext object. Event Context \u00b6 An EventContext object is a light wrapper around the event type you're working with, and it exists only for the duration of your event handler's action . It exists to provide a little extra context and functionality for your event handler. EventContext objects expose the following properties, where T is the same type as the event being handled. Name Type Description breadcrumbs MutableList <Breadcrumb> List of Sentry breadcrumbs, for the Sentry intgration eventHandler EventHandler <T> Current event handler instance event T Current event being handled Additionally, EventContext objects expose the following functions. Name Description breadcrumb Convenience function to create and add a Sentry breadcrumb, for the Sentry intgration Event Types \u00b6 Kord Extensions supports every Kord event, which you can find in Kord's documentation . Kord events are the primary type of event that any bot will be making use of, so it's important to explore Kord's events and figure out what you're going to need. Additionally, Kord Extensions supports custom events. The following additional event types are provided: Type Description ExtensionStateEvent Fired when an extension's loading state changes, containing an ExtensionState enum value that may be FAILED_LOADING , FAILED_UNLOADING , LOADED , LOADING , UNLOADED or UNLOADING Custom Events \u00b6 A custom event may essentially be any type, but events are matched on their types - for example, you can't match specific strings, only the String type. For this reason, the ExtensionEvent interface exists - implement it for your event objects, and use the types you create for matching in your event handlers. To fire your event, you can use the send convenience function on the ExtensibleBot object. 1 2 3 4 5 class NoteEvent ( override val bot : ExtensibleBot , val note : String ) : ExtensionEvent // ... bot . send ( NoteEvent ( bot , \"Sample note\" )) There are no restrictions on what your event can contain or what functionality it exposes. If it makes sense to have a mutable event, feel free!","title":"Events"},{"location":"concepts/events/#events","text":"Events represent a single action, either by a user, Discord itself, or your bot. They're one of the primary ways your bot will react to things happening on Discord, and they're an absolute essential concept to grasp. Subclassing these types While the event handler and context types that are about to be described do support subclassing, we do not currently provide a way to provide your subclasses in the typical manner. If you have a use-case for this then please let us know, and we'll prioritise it!","title":"Events"},{"location":"concepts/events/#event-handlers","text":"In order to react to events, you'll need to add an event handler to your extension. Event handlers represent blocks of code that will be run in response to an event, along with some associated metadata. Creating one is simple - just use the event function in your extension's setup function. 1 2 3 4 5 6 7 8 event < EventClass > { // this: EventHandler<EventClass> check { event -> true } // Return `false` to prevent the action check ( :: returnTrue ) // You can also pass it a function action { // this: EventContext // Code to run when the event is received } } Use the check function to define a set of predicates that must all return true in order for the event handler to be run - you can read more about checks on the Checks page . Once all the checks pass, the action lambda will be called. Note that the action lambda above is a receiver function, where this is bound to an EventContext object.","title":"Event Handlers"},{"location":"concepts/events/#event-context","text":"An EventContext object is a light wrapper around the event type you're working with, and it exists only for the duration of your event handler's action . It exists to provide a little extra context and functionality for your event handler. EventContext objects expose the following properties, where T is the same type as the event being handled. Name Type Description breadcrumbs MutableList <Breadcrumb> List of Sentry breadcrumbs, for the Sentry intgration eventHandler EventHandler <T> Current event handler instance event T Current event being handled Additionally, EventContext objects expose the following functions. Name Description breadcrumb Convenience function to create and add a Sentry breadcrumb, for the Sentry intgration","title":"Event Context"},{"location":"concepts/events/#event-types","text":"Kord Extensions supports every Kord event, which you can find in Kord's documentation . Kord events are the primary type of event that any bot will be making use of, so it's important to explore Kord's events and figure out what you're going to need. Additionally, Kord Extensions supports custom events. The following additional event types are provided: Type Description ExtensionStateEvent Fired when an extension's loading state changes, containing an ExtensionState enum value that may be FAILED_LOADING , FAILED_UNLOADING , LOADED , LOADING , UNLOADED or UNLOADING","title":"Event Types"},{"location":"concepts/events/#custom-events","text":"A custom event may essentially be any type, but events are matched on their types - for example, you can't match specific strings, only the String type. For this reason, the ExtensionEvent interface exists - implement it for your event objects, and use the types you create for matching in your event handlers. To fire your event, you can use the send convenience function on the ExtensibleBot object. 1 2 3 4 5 class NoteEvent ( override val bot : ExtensibleBot , val note : String ) : ExtensionEvent // ... bot . send ( NoteEvent ( bot , \"Sample note\" )) There are no restrictions on what your event can contain or what functionality it exposes. If it makes sense to have a mutable event, feel free!","title":"Custom Events"},{"location":"concepts/extensions/","text":"Extensions \u00b6 Extensions represent defined units of functionality. They provide a way for you to group event handling and command logic together into logical blocks that can be managed individually from each other. While it is technically possible to create commands and event handlers without extensions, we recommend extensions for all use-cases. If you have a use-case that extensions don't cover, please let us know. Extensions support the following features: String name references and public APIs Loading/unloading at runtime, with custom setup/teardown logic Registered event handlers with custom event support Standalone commands with rich metadata Infinitely nestable command groups Extension basics \u00b6 When writing an extension, the first thing you'll need to do is extend the Extension class and implement its abstract members - the name property and setup function. 1 2 3 4 5 6 7 8 class TextExtension : Extension () { // The name this extension will be referred to by override val name : String = \"test\" override suspend fun setup () { // The majority of our extension logic goes here } } Once we've created our extension object, we'll need to register it to our bot object . 1 2 3 4 5 6 7 8 9 val bot = ExtensibleBot ( token ) { extensions { add ( :: TextExtension ) } } suspend fun main () { bot . start () } Our basic extension is complete - it'll be loaded up and functional by the time the bot has connected to Discord. That said, it's a bit boring - let's try adding some functionality to it. There are three common behavioural patterns your extension is likely to implement. Reacting to events \u00b6 As an example, say we wanted to reply to users that say \"ping\" with \"pong\". For this contrived example, we could write an event handler that reacts to message creation events. 1 2 3 4 5 6 7 8 9 10 // Within your extension class... override suspend fun setup () { event < MessageCreateEvent > { action { if ( event . message . content . equals ( \"ping\" , true )) { event . message . respond ( \"pong\" ) } } } } Custom events This is not limited to Kord events - pretty much any object can be an event, although we recommend extending ExtensionEvent for your own events. To send an event, you can use ExtensibleBot#send(event) . For more information on working with events, please see the events page . Reacting to commands \u00b6 Commands are one of the most common methods of interaction with any Discord bot. For this reason, Kord Extensions provides a comprehensive, rich commands framework. For example, we could rewrite the ping example above as a command instead. 1 2 3 4 5 6 7 8 9 override suspend fun setup () { command { name = \"ping\" action { message . respond ( \"pong\" ) } } } Similarly, we support Discord's slash commands. For example: 1 2 3 4 5 6 7 8 9 10 11 12 override suspend fun setup () { slashCommand { name = \"ping\" description = \"Ping!\" action { followUp { content = \"pong\" } } } } Further functionality The commands framework is a deep, rich and feature-filled system that aims to support bot developers by making it as simple as possible to define commands that validate themselves and automatically parse their arguments. It also provides a set of classes that can be extended in order to further customize the behaviour of the commands system. The future of commands Parts of the commands framework are in the middle of being rewritten. That said, the commands system should be stable between versions - that is to say, we'll increment the version number before breaking it. We're hoping to expand upon this system in future, starting with a command dispatcher system that allows you to specify additional command dispatchers with their own prefixes and sets of commands, and switch out the argument parser used. This is a long way off, though, so we recommend keeping an eye on the GitHub repository if you're waiting for this. For more information on working with commands, please see the commands page . Polling and relaying \u00b6 For some bots, you'll need to work with external services. A common use-case is polling an external service and posting changes to a Discord channel, which you can do with Kotlin's Jobs. For this example, we'll write a quick extension that polls something every 30 seconds, and sends a message to a channel with updates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 30 seconds in milliseconds private const val INTERVAL = 1000L * 30L // 10 seconds in milliseconds - use this if you need to wait for // guild members (for example) to be populated. private const val SETUP_DELAY = 1000L * 10L class CheckExtension : Extension () { override val name : String = \"check\" private var data : String = \"\" // ...or whatever private var job : Job? = null override suspend fun setup () { // Iniital setup should always happen after the ReadyEvent. This // is because the ReadyEvent handler has some special logic. // You can read more about that on the events page. event < ReadyEvent > { action { delay ( SETUP_DELAY ) // Launch a job in Kord's coroutine scope job = bot . kord . launch { while ( true ) { delay ( INTERVAL ) val changed = doCheck () // Whatever it is if ( changed ) { getChannel (). createMessage ( \"Data updated: $ data \" ) } } } } } } override suspend fun unload () { // This will be called if the extension is unloaded at any point, // we should stop the job if that happens. job ?. cancel () } } The important thing to note here is that we're launching the job in Kord's coroutine scope, which gives us a Job object we can keep track of. While extensions won't be automatically unloaded, extensions are able to load and unload each other, and all extensions are expected to support this behaviour. If you can't support unloading in your extension for some reason, remember to override unload() and throw an exception! Class Members \u00b6 The Extension class exposes several useful members, and some internal ones. Because we can't possibly know exactly what you need from this system, we don't hide the functional parts - but the below table will mark the things you probably don't need with a . Properties \u00b6 Name Type Description name String The name of the extension, which is how it'll be referred to throughout the bot. bundle String The name of the translation bundle this extension should use, if any. eventHandlers MutableList <EventHandler> List of event handlers registered to this extension. commands MutableList <Command> List of commands registered to this extension. loaded Boolean Whether the extension is currently loaded - this is set automatically. Functions \u00b6 Name Description command Create a new message command for this extension. event Create a new event handler for this extension. group Create a new grouped message command for this extension (a message command that can have subcommands). setup Override this and add all of your setup logic for the extension. slashCommand Create a new slash command for this extension. unload Override this if you need to clean up when your extension is unloaded. doSetup Called by the bot when setting up the extension, firing events and handling extra setup tasks. doUnload Called by the bot when unloading the extension, firing events, unregistering event handlers and commands and handling extra cleanup.","title":"Extensions"},{"location":"concepts/extensions/#extensions","text":"Extensions represent defined units of functionality. They provide a way for you to group event handling and command logic together into logical blocks that can be managed individually from each other. While it is technically possible to create commands and event handlers without extensions, we recommend extensions for all use-cases. If you have a use-case that extensions don't cover, please let us know. Extensions support the following features: String name references and public APIs Loading/unloading at runtime, with custom setup/teardown logic Registered event handlers with custom event support Standalone commands with rich metadata Infinitely nestable command groups","title":"Extensions"},{"location":"concepts/extensions/#extension-basics","text":"When writing an extension, the first thing you'll need to do is extend the Extension class and implement its abstract members - the name property and setup function. 1 2 3 4 5 6 7 8 class TextExtension : Extension () { // The name this extension will be referred to by override val name : String = \"test\" override suspend fun setup () { // The majority of our extension logic goes here } } Once we've created our extension object, we'll need to register it to our bot object . 1 2 3 4 5 6 7 8 9 val bot = ExtensibleBot ( token ) { extensions { add ( :: TextExtension ) } } suspend fun main () { bot . start () } Our basic extension is complete - it'll be loaded up and functional by the time the bot has connected to Discord. That said, it's a bit boring - let's try adding some functionality to it. There are three common behavioural patterns your extension is likely to implement.","title":"Extension basics"},{"location":"concepts/extensions/#reacting-to-events","text":"As an example, say we wanted to reply to users that say \"ping\" with \"pong\". For this contrived example, we could write an event handler that reacts to message creation events. 1 2 3 4 5 6 7 8 9 10 // Within your extension class... override suspend fun setup () { event < MessageCreateEvent > { action { if ( event . message . content . equals ( \"ping\" , true )) { event . message . respond ( \"pong\" ) } } } } Custom events This is not limited to Kord events - pretty much any object can be an event, although we recommend extending ExtensionEvent for your own events. To send an event, you can use ExtensibleBot#send(event) . For more information on working with events, please see the events page .","title":"Reacting to events"},{"location":"concepts/extensions/#reacting-to-commands","text":"Commands are one of the most common methods of interaction with any Discord bot. For this reason, Kord Extensions provides a comprehensive, rich commands framework. For example, we could rewrite the ping example above as a command instead. 1 2 3 4 5 6 7 8 9 override suspend fun setup () { command { name = \"ping\" action { message . respond ( \"pong\" ) } } } Similarly, we support Discord's slash commands. For example: 1 2 3 4 5 6 7 8 9 10 11 12 override suspend fun setup () { slashCommand { name = \"ping\" description = \"Ping!\" action { followUp { content = \"pong\" } } } } Further functionality The commands framework is a deep, rich and feature-filled system that aims to support bot developers by making it as simple as possible to define commands that validate themselves and automatically parse their arguments. It also provides a set of classes that can be extended in order to further customize the behaviour of the commands system. The future of commands Parts of the commands framework are in the middle of being rewritten. That said, the commands system should be stable between versions - that is to say, we'll increment the version number before breaking it. We're hoping to expand upon this system in future, starting with a command dispatcher system that allows you to specify additional command dispatchers with their own prefixes and sets of commands, and switch out the argument parser used. This is a long way off, though, so we recommend keeping an eye on the GitHub repository if you're waiting for this. For more information on working with commands, please see the commands page .","title":"Reacting to commands"},{"location":"concepts/extensions/#polling-and-relaying","text":"For some bots, you'll need to work with external services. A common use-case is polling an external service and posting changes to a Discord channel, which you can do with Kotlin's Jobs. For this example, we'll write a quick extension that polls something every 30 seconds, and sends a message to a channel with updates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 30 seconds in milliseconds private const val INTERVAL = 1000L * 30L // 10 seconds in milliseconds - use this if you need to wait for // guild members (for example) to be populated. private const val SETUP_DELAY = 1000L * 10L class CheckExtension : Extension () { override val name : String = \"check\" private var data : String = \"\" // ...or whatever private var job : Job? = null override suspend fun setup () { // Iniital setup should always happen after the ReadyEvent. This // is because the ReadyEvent handler has some special logic. // You can read more about that on the events page. event < ReadyEvent > { action { delay ( SETUP_DELAY ) // Launch a job in Kord's coroutine scope job = bot . kord . launch { while ( true ) { delay ( INTERVAL ) val changed = doCheck () // Whatever it is if ( changed ) { getChannel (). createMessage ( \"Data updated: $ data \" ) } } } } } } override suspend fun unload () { // This will be called if the extension is unloaded at any point, // we should stop the job if that happens. job ?. cancel () } } The important thing to note here is that we're launching the job in Kord's coroutine scope, which gives us a Job object we can keep track of. While extensions won't be automatically unloaded, extensions are able to load and unload each other, and all extensions are expected to support this behaviour. If you can't support unloading in your extension for some reason, remember to override unload() and throw an exception!","title":"Polling and relaying"},{"location":"concepts/extensions/#class-members","text":"The Extension class exposes several useful members, and some internal ones. Because we can't possibly know exactly what you need from this system, we don't hide the functional parts - but the below table will mark the things you probably don't need with a .","title":"Class Members"},{"location":"concepts/extensions/#properties","text":"Name Type Description name String The name of the extension, which is how it'll be referred to throughout the bot. bundle String The name of the translation bundle this extension should use, if any. eventHandlers MutableList <EventHandler> List of event handlers registered to this extension. commands MutableList <Command> List of commands registered to this extension. loaded Boolean Whether the extension is currently loaded - this is set automatically.","title":"Properties"},{"location":"concepts/extensions/#functions","text":"Name Description command Create a new message command for this extension. event Create a new event handler for this extension. group Create a new grouped message command for this extension (a message command that can have subcommands). setup Override this and add all of your setup logic for the extension. slashCommand Create a new slash command for this extension. unload Override this if you need to clean up when your extension is unloaded. doSetup Called by the bot when setting up the extension, firing events and handling extra setup tasks. doUnload Called by the bot when unloading the extension, firing events, unregistering event handlers and commands and handling extra cleanup.","title":"Functions"},{"location":"concepts/i18n/","text":"Internationalisation \u00b6 Internationalisation (hereafter i18n) is an important consideration for many applications. If you're catering to a global audience, then it's important to think about how you might provide translated messages for your users - and to format things like dates in the format they expect. As there's nothing comparable in the Kotlin multi-platform ecosystem, KordEx makes use of Java tooling when working with translations. Specifically, translations are collected into .properties -based resource bundles, and parsed using the ICU Message Format . Messages are referenced using a translation key , usually a string containing alphanumeric identifiers separated with dots ( . ). You can programmatically retrieve the locales we have translations for from the SupportedLocales object. Accessing Translations \u00b6 You can make use of translation keys in the following contexts, and they'll be translated automatically: Command names and descriptions Command argument descriptions (but not names) Message.respondTranslated() extension function provided by MessageCommandContext Additionally, shortcuts for translating strings yourself exist: In CommandContext , which has a translate function In EventContext , which provides a translate extension method for Event objects You can also make use of the bot's translations provider via Koin, using the TranslationsProvider interface. Translations are optional In some situations - for example, during initial testing or if you're working on a bespoke bot - it may not be necessary (or even desirable) to include translations. In these cases, you can ignore that translations exist and just type the text you want instead. Note: If a translation key is missing from your translations bundle, it will be used verbatim instead. Make sure you test your bots after you've set up translations! Working With Translations \u00b6 There are multiple approaches you can use when writing translation-friendly code: Write the code without thinking about translations, and move the strings into your translations after everything is working Write the code with translations in mind by using translation keys from the start, and create translations for them as you go, or after everything else works Whichever approach you take, you'll need to come up with a set of translation keys. These should be descriptive string identifiers, which help you understand where they're used and what they're used for. Good: extensions.posts.create.embed.title Bad: title You'll also need to create a translation bundle. Translation Bundles \u00b6 Translation bundles are sets of .properties files with a matching prefix, stored within a common directory in your bot's resources - specifically, the translations directory. Bundles are represented by a string name, and they should always contain at least two parts, split with a dot ( . ). If you're writing an extension, override the bundle property with the name of your bundle and the Context -based convenience functions will make use of it automatically. For simple bots and extensions, we recommend using the project name and strings - so if your project is named \"posts\", you could use posts.strings . This will correspond with .properties files starting with strings , in translations/posts in your bot's resources. Translations files include the locale they contain translations for in their name, split by underscores. In our example, a translations file containing French (France) would be named strings_fr_FR.properties . A more general French translations file may be named strings_fr.properties instead. These names directly correspond with Java Locale objects - a Locale object created via Locale(\"en\", \"gb\") would correspond with a file named strings_en_GB , for example. Ultimately, it's up to the bot developer to decide what Locale objects to use - you should document which locales you support, and provide a way for your users to contribute translations. Note: Default translations should always be in English, as this is the locale the bot will use if no other locale is specified. You should place your default translations in a file that doesn't include a locale code - in our example, this would simply be strings.properties . Formatting and Replacements \u00b6 As mentioned earlier, translations should use the ICU Message Format . This allows for very flexible message formatting, allowing for locale-aware insertion of variables, among other things. While we suggest you read the linked document for a deep dive into the format, we'll cover the basics below. The first thing to be aware of is the .properties file format. Properties files contain simple key-value pairs, like the following: 1 2 3 permission.addReactions = Add Reactions permission.administrator = Administrator permission.all = All Permissions String values may be split among multiple lines, by ending the line with a backslash ( \\ ) character and moving to the next line. Spaces will be trimmed from either side of each line, and the line breaks will not be preserved in the string - you can use a normal line break sequence ( \\n ) to include one. It's common to see the newline-with-line-break pattern ( \\n\\ ) in some translation files for this reason. 1 2 3 4 5 6 7 8 extensions.help.error.missingCommandTitle = Command not found extensions.help.error.missingCommandDescription = Unable to find that command. This may be for one of several possible reasons: \\n\\ \\n\\ **\u00bb** The command doesn't exist or failed to load\\n\\ **\u00bb** The command isn't available in this context\\n\\ **\u00bb** You don't have access to the command\\n\\ \\n\\ If you feel that this is incorrect, please contact a member of staff. Additionally, messages may contain tokens to be replaced. Tokens reference the items in the replacements array that can be passed into all translation functions, by their index - starting a 0 . A simple variable insertion looks like the following: 1 2 paginator.footer.page = Page {0}/{1} paginator.footer.group = Group {0}/{1} Given an array like that returned by arrayOf(1, 3) , this would result in a string like \"Page 1/3\" . However, there are several more advanced ways to format the given replacements. Number Formatting \u00b6 Note: Custom formats are usually not necessary - the appropriate format for the locale should be used automatically. Auto: {0, number} Integer: {0, number, integer} Currency: $ {0, number, currency} Percent: {0, number, percent}% Custom format: {0, number, ###,###.###} (this uses Java's DecimalFormat ) Date Formatting \u00b6 Note: Custom formats are usually not necessary - the appropriate format for the locale should be used automatically. Auto: {0, date} Short: {0, date, short} Medium: {0, date, medium} Long: {0, date, long} Full: {0, date, full} Custom format: {0, date, dd/MM/yyyy} (this uses Java's SimpleDateFormat ) Time Formatting \u00b6 Note: Custom formats are usually not necessary - the appropriate format for the locale should be used automatically. Auto: {0, time} Short: {0, time, short} Medium: {0, time, medium} Long: {0, time, long} Full: {0, time, full} Custom format: {0, time, kk:mm:ss} (this uses Java's SimpleDateFormat ) Advanced Numeric Formatting \u00b6 Duration: {0, duration} - Used when you want to format a number as a simple duration - for example, 123 becomes 2:03 in English (123 seconds is 2 minutes and 3 seconds) Ordinal: {0, ordinal} - Used when you want to append an ordinal suffix to a number - for example, 3 becomes \" 3rd \" in English Spellout: {0, spellout} - Used when you want to format a numeric value as text - for example, 100 becomes \"one hundred\" in English Note: Just like the other formats, you can include a custom format string by adding a comma ( , ) and the string. This makes use of the ICU RuleBasedNumberFormat class . Selections \u00b6 Selections can be used to specify a different translation based on a string provided in the replacements array. THis can be useful when dealing with languages that have different words based on the gender of a person - assuming you have access to that information. For example: 1 2 3 4 5 actions.chop.tree = {0, select,\\ female { She }\\ male { He }\\ other { They }\\ } chopped down the tree. Pluralisation \u00b6 When you have a variable number of something, you should pluralize only when necessary. For example: 1 2 3 4 actions.chop.tree = They chopped down {0} {0, plural,\\ =1 { tree }\\ other { trees }\\ }. Advanced Nesting \u00b6 When working with selections and pluralisation, you can also nest other replacement tokens inside their content. For example: 1 2 3 4 5 actions.chop.tree = {0, select,\\ female { She chopped down {1} {1, plural, =1 { tree } other { trees }} }\\ male { He chopped down {1} {1, plural, =1 { tree } other { trees }} }\\ other { They chopped down {1} {1, plural, =1 { tree } other { trees }} }\\ } The above example isn't the best way to structure the given string - it's just a contrived example. See if you can figure out a better way to format it - you should be able to do it without nesting tokens!","title":"Internationalisation"},{"location":"concepts/i18n/#internationalisation","text":"Internationalisation (hereafter i18n) is an important consideration for many applications. If you're catering to a global audience, then it's important to think about how you might provide translated messages for your users - and to format things like dates in the format they expect. As there's nothing comparable in the Kotlin multi-platform ecosystem, KordEx makes use of Java tooling when working with translations. Specifically, translations are collected into .properties -based resource bundles, and parsed using the ICU Message Format . Messages are referenced using a translation key , usually a string containing alphanumeric identifiers separated with dots ( . ). You can programmatically retrieve the locales we have translations for from the SupportedLocales object.","title":"Internationalisation"},{"location":"concepts/i18n/#accessing-translations","text":"You can make use of translation keys in the following contexts, and they'll be translated automatically: Command names and descriptions Command argument descriptions (but not names) Message.respondTranslated() extension function provided by MessageCommandContext Additionally, shortcuts for translating strings yourself exist: In CommandContext , which has a translate function In EventContext , which provides a translate extension method for Event objects You can also make use of the bot's translations provider via Koin, using the TranslationsProvider interface. Translations are optional In some situations - for example, during initial testing or if you're working on a bespoke bot - it may not be necessary (or even desirable) to include translations. In these cases, you can ignore that translations exist and just type the text you want instead. Note: If a translation key is missing from your translations bundle, it will be used verbatim instead. Make sure you test your bots after you've set up translations!","title":"Accessing Translations"},{"location":"concepts/i18n/#working-with-translations","text":"There are multiple approaches you can use when writing translation-friendly code: Write the code without thinking about translations, and move the strings into your translations after everything is working Write the code with translations in mind by using translation keys from the start, and create translations for them as you go, or after everything else works Whichever approach you take, you'll need to come up with a set of translation keys. These should be descriptive string identifiers, which help you understand where they're used and what they're used for. Good: extensions.posts.create.embed.title Bad: title You'll also need to create a translation bundle.","title":"Working With Translations"},{"location":"concepts/i18n/#translation-bundles","text":"Translation bundles are sets of .properties files with a matching prefix, stored within a common directory in your bot's resources - specifically, the translations directory. Bundles are represented by a string name, and they should always contain at least two parts, split with a dot ( . ). If you're writing an extension, override the bundle property with the name of your bundle and the Context -based convenience functions will make use of it automatically. For simple bots and extensions, we recommend using the project name and strings - so if your project is named \"posts\", you could use posts.strings . This will correspond with .properties files starting with strings , in translations/posts in your bot's resources. Translations files include the locale they contain translations for in their name, split by underscores. In our example, a translations file containing French (France) would be named strings_fr_FR.properties . A more general French translations file may be named strings_fr.properties instead. These names directly correspond with Java Locale objects - a Locale object created via Locale(\"en\", \"gb\") would correspond with a file named strings_en_GB , for example. Ultimately, it's up to the bot developer to decide what Locale objects to use - you should document which locales you support, and provide a way for your users to contribute translations. Note: Default translations should always be in English, as this is the locale the bot will use if no other locale is specified. You should place your default translations in a file that doesn't include a locale code - in our example, this would simply be strings.properties .","title":"Translation Bundles"},{"location":"concepts/i18n/#formatting-and-replacements","text":"As mentioned earlier, translations should use the ICU Message Format . This allows for very flexible message formatting, allowing for locale-aware insertion of variables, among other things. While we suggest you read the linked document for a deep dive into the format, we'll cover the basics below. The first thing to be aware of is the .properties file format. Properties files contain simple key-value pairs, like the following: 1 2 3 permission.addReactions = Add Reactions permission.administrator = Administrator permission.all = All Permissions String values may be split among multiple lines, by ending the line with a backslash ( \\ ) character and moving to the next line. Spaces will be trimmed from either side of each line, and the line breaks will not be preserved in the string - you can use a normal line break sequence ( \\n ) to include one. It's common to see the newline-with-line-break pattern ( \\n\\ ) in some translation files for this reason. 1 2 3 4 5 6 7 8 extensions.help.error.missingCommandTitle = Command not found extensions.help.error.missingCommandDescription = Unable to find that command. This may be for one of several possible reasons: \\n\\ \\n\\ **\u00bb** The command doesn't exist or failed to load\\n\\ **\u00bb** The command isn't available in this context\\n\\ **\u00bb** You don't have access to the command\\n\\ \\n\\ If you feel that this is incorrect, please contact a member of staff. Additionally, messages may contain tokens to be replaced. Tokens reference the items in the replacements array that can be passed into all translation functions, by their index - starting a 0 . A simple variable insertion looks like the following: 1 2 paginator.footer.page = Page {0}/{1} paginator.footer.group = Group {0}/{1} Given an array like that returned by arrayOf(1, 3) , this would result in a string like \"Page 1/3\" . However, there are several more advanced ways to format the given replacements.","title":"Formatting and Replacements"},{"location":"concepts/i18n/#number-formatting","text":"Note: Custom formats are usually not necessary - the appropriate format for the locale should be used automatically. Auto: {0, number} Integer: {0, number, integer} Currency: $ {0, number, currency} Percent: {0, number, percent}% Custom format: {0, number, ###,###.###} (this uses Java's DecimalFormat )","title":"Number Formatting"},{"location":"concepts/i18n/#date-formatting","text":"Note: Custom formats are usually not necessary - the appropriate format for the locale should be used automatically. Auto: {0, date} Short: {0, date, short} Medium: {0, date, medium} Long: {0, date, long} Full: {0, date, full} Custom format: {0, date, dd/MM/yyyy} (this uses Java's SimpleDateFormat )","title":"Date Formatting"},{"location":"concepts/i18n/#time-formatting","text":"Note: Custom formats are usually not necessary - the appropriate format for the locale should be used automatically. Auto: {0, time} Short: {0, time, short} Medium: {0, time, medium} Long: {0, time, long} Full: {0, time, full} Custom format: {0, time, kk:mm:ss} (this uses Java's SimpleDateFormat )","title":"Time Formatting"},{"location":"concepts/i18n/#advanced-numeric-formatting","text":"Duration: {0, duration} - Used when you want to format a number as a simple duration - for example, 123 becomes 2:03 in English (123 seconds is 2 minutes and 3 seconds) Ordinal: {0, ordinal} - Used when you want to append an ordinal suffix to a number - for example, 3 becomes \" 3rd \" in English Spellout: {0, spellout} - Used when you want to format a numeric value as text - for example, 100 becomes \"one hundred\" in English Note: Just like the other formats, you can include a custom format string by adding a comma ( , ) and the string. This makes use of the ICU RuleBasedNumberFormat class .","title":"Advanced Numeric Formatting"},{"location":"concepts/i18n/#selections","text":"Selections can be used to specify a different translation based on a string provided in the replacements array. THis can be useful when dealing with languages that have different words based on the gender of a person - assuming you have access to that information. For example: 1 2 3 4 5 actions.chop.tree = {0, select,\\ female { She }\\ male { He }\\ other { They }\\ } chopped down the tree.","title":"Selections"},{"location":"concepts/i18n/#pluralisation","text":"When you have a variable number of something, you should pluralize only when necessary. For example: 1 2 3 4 actions.chop.tree = They chopped down {0} {0, plural,\\ =1 { tree }\\ other { trees }\\ }.","title":"Pluralisation"},{"location":"concepts/i18n/#advanced-nesting","text":"When working with selections and pluralisation, you can also nest other replacement tokens inside their content. For example: 1 2 3 4 5 actions.chop.tree = {0, select,\\ female { She chopped down {1} {1, plural, =1 { tree } other { trees }} }\\ male { He chopped down {1} {1, plural, =1 { tree } other { trees }} }\\ other { They chopped down {1} {1, plural, =1 { tree } other { trees }} }\\ } The above example isn't the best way to structure the given string - it's just a contrived example. See if you can figure out a better way to format it - you should be able to do it without nesting tokens!","title":"Advanced Nesting"},{"location":"integrations/koin/","text":"Koin \u00b6 Koin is a lightweight service locator framework, written in pure Kotlin. It's a fairly popular framework that's often used in place of a larger dependency injection framework like Dagger, and Kord Extensions supports it as a first-class citizen. Do I have to use this? Koin integration is entirely optional, but it cannot be unbundled from the main distribution at the moment. The integration is still in the early stages, and will be made more useful over time. We expect Koin integration to be more useful for users developing their own extensions, but you are of course free to make use of it however you like. Koin contexts Koin is designed to be used with a single global context by default. In order to support multiple individual bots in one application, however, Kord Extensions creates a separate Koin context for every instance of ExtensibleBot . You can access it on the ExtensibleBot#koin property. Registering modules \u00b6 In order to register a Koin module, call the koin.loadModules function before you start your bot. 1 2 3 4 5 6 7 8 9 10 11 12 13 val config = MyBotConfig () val bot = ExtensibleBot ( config . token ) { commands { prefix = config . prefix } } suspend fun main () { bot . koin . module { single { config } } bot . start () } Using Koin \u00b6 All extensions inherit KoinComponent , which means that all relevant Koin functions will be present within the extension. You can make use of these directly - Kord Extensions makes use of the global Koin instance. 1 2 3 class MyExtension ( bot : ExtensibleBot ) : KoinExtension ( bot ) { val sentry : SentryAdapter by inject () } Bundled modules \u00b6 The following modules are registered automatically. They do not have any qualifiers (it wouldn't make sense to have multiple instances registered at once in most cases), but you can supply your own alternatives as necessary by passing override = true to the module function when you create your module. Type Notes ExtensibleBot The current instance of the bot ExtensibleBotBuilder The current extensible bot settings object Kord Current Kord instance, registered after bot.start() is called MessageCommandRegistry Class that keeps track of message commands, and is in charge of executing them and finding the right prefixes SentryAdapter Sentry adapter created for the Sentry integration SlashCommandRegistry Class that keeps track of slash commands, and is in charge of executing and registering them TranslationsProvider Class providing access to translations We'll be updating this list further as parts of Kord Extensions are modularized.","title":"Koin"},{"location":"integrations/koin/#koin","text":"Koin is a lightweight service locator framework, written in pure Kotlin. It's a fairly popular framework that's often used in place of a larger dependency injection framework like Dagger, and Kord Extensions supports it as a first-class citizen. Do I have to use this? Koin integration is entirely optional, but it cannot be unbundled from the main distribution at the moment. The integration is still in the early stages, and will be made more useful over time. We expect Koin integration to be more useful for users developing their own extensions, but you are of course free to make use of it however you like. Koin contexts Koin is designed to be used with a single global context by default. In order to support multiple individual bots in one application, however, Kord Extensions creates a separate Koin context for every instance of ExtensibleBot . You can access it on the ExtensibleBot#koin property.","title":"Koin"},{"location":"integrations/koin/#registering-modules","text":"In order to register a Koin module, call the koin.loadModules function before you start your bot. 1 2 3 4 5 6 7 8 9 10 11 12 13 val config = MyBotConfig () val bot = ExtensibleBot ( config . token ) { commands { prefix = config . prefix } } suspend fun main () { bot . koin . module { single { config } } bot . start () }","title":"Registering modules"},{"location":"integrations/koin/#using-koin","text":"All extensions inherit KoinComponent , which means that all relevant Koin functions will be present within the extension. You can make use of these directly - Kord Extensions makes use of the global Koin instance. 1 2 3 class MyExtension ( bot : ExtensibleBot ) : KoinExtension ( bot ) { val sentry : SentryAdapter by inject () }","title":"Using Koin"},{"location":"integrations/koin/#bundled-modules","text":"The following modules are registered automatically. They do not have any qualifiers (it wouldn't make sense to have multiple instances registered at once in most cases), but you can supply your own alternatives as necessary by passing override = true to the module function when you create your module. Type Notes ExtensibleBot The current instance of the bot ExtensibleBotBuilder The current extensible bot settings object Kord Current Kord instance, registered after bot.start() is called MessageCommandRegistry Class that keeps track of message commands, and is in charge of executing them and finding the right prefixes SentryAdapter Sentry adapter created for the Sentry integration SlashCommandRegistry Class that keeps track of slash commands, and is in charge of executing and registering them TranslationsProvider Class providing access to translations We'll be updating this list further as parts of Kord Extensions are modularized.","title":"Bundled modules"},{"location":"integrations/sentry/","text":"Sentry \u00b6 Sentry is a web-based tool used for keeping track of errors in your applications. Kord Extensions provides a first-party build-in integration for anyone that uses Sentry to keep track of errors in their production bots, with full support for breadcrumbs in your commands and event handlers so you can tell Sentry exactly what went wrong. Discord webhooks? Sentry does not support Discord webhooks out of the box - however, Discord does support Slack-format webhooks. As Slack requires current integrations to use OAuth, Sentry has hidden their legacy integration - but it can still be used. To find it, head to the settings for your project and append /plugins/slack/ to the URL - for example, https://sentry.io/settings/my-org/projects/bot/plugins/slack/ . The webhook URL should also have /slack appended, so it looks like this: https://discord.com/api/webhooks/{ID}/{TOKEN}/slack Setting up \u00b6 Kord Extensions ships with the Sentry library by default, but no logging integration - we recommend matching the version of your logging integration with the Sentry library shipped with Kord, but of course you can treat it just like any other transitive dependency. The ExtensibleBot object contains a sentry property referring to a SentryAdapter instance - to enable the Sentry integration, you'll need to set this object up using its init function. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 val bot = ExtensibleBot ( TOKEN ) { commands { prefix = \"!\" } } if ( env ( \"SENTRY_DSN\" ) != null ) { bot . sentry . init { dsn = env ( \"SENTRY_DSN\" ) environment = env ( \"ENVIRONMENT\" ) ?: \"production\" release = \"...\" // However you get your Sentry release info } } There's an alternative version of the init function that you can pass parameters to instead, but we highly recommend the use of the lambda-based function since it directly maps to Sentry's own init method. Adding context to errors \u00b6 Sentry's main method of collecting error context is to add breadcrumbs. Breadcrumbs essentially record the steps that were taken to reach your problem, including extra data that can provide additional context. Commands and event handlers both have built-in Sentry reporting, and include a mechanism for keeping track of breadcrumbs that you add as your command or event is processing. You can do this in one of two ways: Use the breadcrumb function on the CommandContext or EventContext object to add a breadcrumb Use the breadcrumbs mutable list on the CommandContext or EventContext object, and use the bot.sentry.createBreadcrumb function to create breadcrumbs to add to it - this is particularly useful if you need to pass the list around to different functions to collect breadcrumbs from them When an error occurs, the bot will create a Sentry scope configured with information about the command or event that caused the error, and it'll create an initial breadcrumb corresponding to the start of processing. It'll then take all the breadcrumbs you created, add them to the scope, and submit the scope directly to Sentry. There's nothing more that you need to do - you'll see the issue appear in Sentry with all of its breadcrumbs and associated context! For a list of supported breadcrumb types, please see the Sentry documentation . Collecting user feedback \u00b6 If an error occurs during command processing, and you have the Sentry extension enabled (which it is by default), the returned error message will contain a Sentry ID and information on how to submit a piece of user feedback. This includes a feedback command, which will be automatically registered by the Sentry extension. If you wish to disable this, pass false for the addSentryExtension constructor param for your ExtensibleBot instance, and both the Sentry ID in the error and the feedback command will be disabled. Manual usage \u00b6 You can, of course, make use of Sentry as per its documentation . However, bear in mind that both Kord and Kord Extensions are coroutine-based, and that means that a lot of the things you do will be asynchronous. Because of this, you'll want to collect breadcrumbs and other context yourself instead of creating a scope early - the best way of doing this is with a simple list of Breadcrumb objects. When an error happens, you can create the Sentry scope, add the breadcrumbs and other context, and submit it all at once. Failure to do this will result in issues, as Sentry uses a simple stack that it pushes and pops scopes onto without regard for any context - so you may end up adding breadcrumbs to the wrong scope, or submitting a scope from another part of the application too early if you don't watch out for this!","title":"Sentry"},{"location":"integrations/sentry/#sentry","text":"Sentry is a web-based tool used for keeping track of errors in your applications. Kord Extensions provides a first-party build-in integration for anyone that uses Sentry to keep track of errors in their production bots, with full support for breadcrumbs in your commands and event handlers so you can tell Sentry exactly what went wrong. Discord webhooks? Sentry does not support Discord webhooks out of the box - however, Discord does support Slack-format webhooks. As Slack requires current integrations to use OAuth, Sentry has hidden their legacy integration - but it can still be used. To find it, head to the settings for your project and append /plugins/slack/ to the URL - for example, https://sentry.io/settings/my-org/projects/bot/plugins/slack/ . The webhook URL should also have /slack appended, so it looks like this: https://discord.com/api/webhooks/{ID}/{TOKEN}/slack","title":"Sentry"},{"location":"integrations/sentry/#setting-up","text":"Kord Extensions ships with the Sentry library by default, but no logging integration - we recommend matching the version of your logging integration with the Sentry library shipped with Kord, but of course you can treat it just like any other transitive dependency. The ExtensibleBot object contains a sentry property referring to a SentryAdapter instance - to enable the Sentry integration, you'll need to set this object up using its init function. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 val bot = ExtensibleBot ( TOKEN ) { commands { prefix = \"!\" } } if ( env ( \"SENTRY_DSN\" ) != null ) { bot . sentry . init { dsn = env ( \"SENTRY_DSN\" ) environment = env ( \"ENVIRONMENT\" ) ?: \"production\" release = \"...\" // However you get your Sentry release info } } There's an alternative version of the init function that you can pass parameters to instead, but we highly recommend the use of the lambda-based function since it directly maps to Sentry's own init method.","title":"Setting up"},{"location":"integrations/sentry/#adding-context-to-errors","text":"Sentry's main method of collecting error context is to add breadcrumbs. Breadcrumbs essentially record the steps that were taken to reach your problem, including extra data that can provide additional context. Commands and event handlers both have built-in Sentry reporting, and include a mechanism for keeping track of breadcrumbs that you add as your command or event is processing. You can do this in one of two ways: Use the breadcrumb function on the CommandContext or EventContext object to add a breadcrumb Use the breadcrumbs mutable list on the CommandContext or EventContext object, and use the bot.sentry.createBreadcrumb function to create breadcrumbs to add to it - this is particularly useful if you need to pass the list around to different functions to collect breadcrumbs from them When an error occurs, the bot will create a Sentry scope configured with information about the command or event that caused the error, and it'll create an initial breadcrumb corresponding to the start of processing. It'll then take all the breadcrumbs you created, add them to the scope, and submit the scope directly to Sentry. There's nothing more that you need to do - you'll see the issue appear in Sentry with all of its breadcrumbs and associated context! For a list of supported breadcrumb types, please see the Sentry documentation .","title":"Adding context to errors"},{"location":"integrations/sentry/#collecting-user-feedback","text":"If an error occurs during command processing, and you have the Sentry extension enabled (which it is by default), the returned error message will contain a Sentry ID and information on how to submit a piece of user feedback. This includes a feedback command, which will be automatically registered by the Sentry extension. If you wish to disable this, pass false for the addSentryExtension constructor param for your ExtensibleBot instance, and both the Sentry ID in the error and the feedback command will be disabled.","title":"Collecting user feedback"},{"location":"integrations/sentry/#manual-usage","text":"You can, of course, make use of Sentry as per its documentation . However, bear in mind that both Kord and Kord Extensions are coroutine-based, and that means that a lot of the things you do will be asynchronous. Because of this, you'll want to collect breadcrumbs and other context yourself instead of creating a scope early - the best way of doing this is with a simple list of Breadcrumb objects. When an error happens, you can create the Sentry scope, add the breadcrumbs and other context, and submit it all at once. Failure to do this will result in issues, as Sentry uses a simple stack that it pushes and pops scopes onto without regard for any context - so you may end up adding breadcrumbs to the wrong scope, or submitting a scope from another part of the application too early if you don't watch out for this!","title":"Manual usage"},{"location":"migrating/1.4.0/","text":"1.3.x to 1.4.x \u00b6 Version 1.4.x contains a huge number of changes, encompassing thousands of lines of code and over 90 changed files! It contains many QoL improvements, a rewritten paginator, support for slash commands, and several other features. That said, we couldn't avoid breaking quite a few things during this release cycle. We've detailed the big changes below, but we still advise that you give a quick read over the rest of the documentation as well. Bot Creation & Usage \u00b6 ExtensibleBot is no longer configured using constructor parameters - instead, it provides a builder-pattern DSL for you to use, which also allows you to configure Kord's cache and add extensions. For more information on what exactly you can configure, see the Bot concept page . 1.3.x \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 val bot = ExtensibleBot ( addSentryExtension = false , handleSlashCommands = true , koinLogLevel = Level . DEBUG , prefix = \"!\" , // This is now the default prefix token = System . getenv ( \"TOKEN\" ), ) bot . addExtension ( :: TestExtension ) bot . start { intents { + Intents . all } presence { playing ( \"!help for command help\" ) } } 1.4.x \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 val bot = ExtensibleBot ( env ( \"TOKEN\" ) !! ) { koinLogLevel = Level . DEBUG extensions { sentry = false add ( :: TestExtension ) } intents { + Intents . all } presence { playing ( \"!help for command help\" ) } slashCommands { enable = true } } bot . start () Additionally, the bot has gained the findExtension<T>() and findExtensions<T>() functions, allowing you to search for loaded extensions that match the given type - for example, to find the loaded extension that implements the new HelpProvider interface. Checks \u00b6 Additional checks have been added, along with support for the new interaction events that are made use of by slash commands. The newly-bundled checks allow you to ensure that users have (or do not have) specific permissions . All checks that concern specific entities have been rewritten to take either a DSL-style lambda that resolves to the entity, or a Snowflake that will later be resolved to that entity. This change has been made in order to allow extensions to be set up before the bot connects to Discord, and to improve extension registration times. For more information on this, see the checks concept page . 1.3.x \u00b6 1 2 3 4 5 6 7 event < MessageCreateEvent > { check ( inGuild ( config . guild )) action { // ... } } 1.4.x \u00b6 1 2 3 4 5 6 7 8 9 event < MessageCreateEvent > { // One or the other: check ( inGuild { config . guild }) check ( inGuild ( config . guildId )) action { // ... } } Commands \u00b6 In order to make room for slash commands, the commands system has had somewhat of an overhaul. This includes the following: Command and CommandContext have been rewritten and are now generic base classes. Message-based commands now use the MessageCommand and MessageCommandContext classes, and slash commands similarly make use of the SlashCommand and SlashCommandContext classes. The signature and parse functions used in command bodies have been removed. You can still set a custom signature string in the usual way, though, if you must - but this will result in a loss of information in some cases. To specify your Arguments subclass builder, you now pass it as the first parameter to the command , group or slashCommand function. This will automatically generate the command's signature, and the command's arguments will always be automatically parsed and placed within the arguments property of the current MessageCommandContext in the command's action body. ParseException has been renamed to CommandException , to better reflect the fact that you can throw it when you need to. 1.3.x \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 command { name = \"post\" description = \"Create a post\" signature ( :: PostArguments ) action { // Option 1 val parsed = parse ( :: PostArguments ) message . respond ( \"** ${ parsed . title } ** (by ${ parsed . author . mention } )\\n\\n\" + parsed . body ) // Option 2 with ( parse ( :: PostArguments )) { message . respond ( \"** $ title ** (by ${ author . mention } )\\n\\n\" + body ) } } } 1.4.x \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 command ( :: PostArguments ) { name = \"post\" description = \"Create a post\" action { // Option 1 message . respond ( \"** ${ arguments . title } ** (by ${ arguments . author . mention } )\\n\\n\" + arguments . body ) // Option 2 with ( arguments ) { message . respond ( \"** $ title ** (by ${ author . mention } )\\n\\n\" + body ) } } } Command Arguments & Converters \u00b6 Some major changes have been made to arguments and converters as well, in order to facilitate slash commands and provide extra information in the command help output. All arguments defined in your Arguments subclasses require a description string. This should be a very short, human-readable string that explains what each argument is for. Argument descriptions are used in the bundled help extension, and they're shown on Discord as part of slash commands. Note that, for slash commands, optional arguments must always be specified as the last arguments for the command. Most converter types now implement the SlashCommandConverter interface, which provides the toSlashOption command. All converter types (aside from MultiConverter ) must implement this function, which makes the converter work as a slash command argument. As Discord's available argument types are lacking, please note that in many cases you'll want to tell Discord that your converter is a string converter. Parsing does not change for this purpose - you should continue to implement converters in the usual manner. Coalescing and optional converters now support an additional shouldThrow parameter. This parameter should be used to specify that the converter should throw an exception (which may be a CommandException ) when they fail to parse an argument from the list given to them. This is intended only for arguments that appear as the last argument in the list for a command, where the argument may be omitted but validation still needs to happen for its arguments. Defaulting converters do not support this parameter. Compiler errors (via opt-in annotations) have been added for converter functions that return a wrapped converter that changes the behaviour of the converter being wrapped. This has been done to try to help avoid problems caused by users directly making use of these functions instead of the relevant Arguments class extension functions, which can result in converters being filled incorrectly, the wrong converters being registered, and a myriad of other strange problems. If you're writing your own Arguments class extension functions, feel free to opt-in to these annotations at the file level. You'll need to be able to use these functions to write a full suite of extension functions for your own converters. NumberConverter has been replaced with IntConverter and LongConverter , in case you happen to need ints instead of longs. Please note that Discord only supports integer converters, even if you're using a LongConverter in your slash command arguments - you'll still get a Long , but it's not currently known whether slash commands can actually support numbers that large. All converters that support durations are now equipped with a nice long error message if the user supplies an invalid duration, which will be displayed as appropriate. If you'd rather stick with a short, single-line error, you can supply a false value for the new longHelp parameter for the relevant converter functions. The long error looks like this - the short error will simply use the first line: (for an invalid unit) Invalid duration unit specified: x (for a missing unit) Please specify a unit - bare numbers are not supported. How to use durations Durations are specified in pairs of amounts and units - for example, 12d would be 12 days. Compound durations are supported - for example, 2d12h would be 2 days and 12 hours. The following units are supported: Seconds: s , sec , second , seconds Minutes: m , mi , min , minute , minutes Hours: h , hour , hours Days: d , day , days Weeks: w , week , weeks Months: mo , month , months Years: y , year , years Example: Argument descriptions \u00b6 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" , \"Post title\" ) // Single required Discord user argument val author by user ( \"author\" , \"User that this post should be attributed to\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" , \"Text content to be placed within the posts's body\" ) } Example: toSlashOption \u00b6 1 2 3 4 5 6 7 8 public class IntConverter ( private val radix : Int = 10 ) : SingleConverter < Int > () { // ... override suspend fun toSlashOption ( arg : Argument <*> ): OptionsBuilder = IntChoiceBuilder ( arg . displayName , arg . description ). apply { required = true } } Moved Converters \u00b6 Some converters have been moved to separate modules: Java Time : Duration (Java Time) with special-casing for coalescing conversion Integrations \u00b6 An additional integration for Koin has been added. Koin is a lightweight service locator framework, written in pure Kotlin. It's been gaining in popularity due to its simplicity and low performance overhead, and we've decided to support it in order to make things easier to locate and work with. Koin is fully integrated, and you're expected to use it to retrieve references to different parts of the framework. For more information, we suggest you read the documentation for it . Internationalisation & Localisation \u00b6 KordEx now has full support for i18n! For more information, read the new i18n page . Paginator \u00b6 For those of you that were making use of the included (but undocumented) Paginator class, it's been completely rewritten with support for page groups, embed formatting, dynamic footers, and several other features. As the original Paginator was undocumented (and not really meant to be used in production), we haven't written a specific migration guide for it. Instead, we suggest you read the documentation for it and rewrite your paginator usages to match the new API. Provided Extensions \u00b6 Both of the bundled extensions have been updated to support the new KordEx features available in recent versions. Their package has also changed to make room for extension-specific interfaces. The HelpExtension has been updated to add support for command argument descriptions, using the richer page groups available in the rewritten paginator. You can click the reaction under help embeds to learn more about the displayed commands' arguments. Additionally, all custom help extensions must now implement the HelpProvider interface. This makes it easy for other extensions to, for example, display the help for their command when required. As slash commands (and their arguments) show their own help strings directly on Discord, the help extension does not support them. The SentryExtension has been updated to add a /feedback global slash command, which works just like the feedback message command. If an error occurs during processing of a slash command (and the Sentry extension is enabled), users will be prompted to make use of /feedback instead of the feedback message command. Scheduler \u00b6 The Scheduler class has been entirely rewritten, with a new Task abstraction class. For more information, you should read the Scheduler page . Utilities \u00b6 Many utilities have been created or rewritten during this release cycle. Instead of detailing each change here, we recommend you read the documentation for them .","title":"1.3.x to 1.4.x"},{"location":"migrating/1.4.0/#13x-to-14x","text":"Version 1.4.x contains a huge number of changes, encompassing thousands of lines of code and over 90 changed files! It contains many QoL improvements, a rewritten paginator, support for slash commands, and several other features. That said, we couldn't avoid breaking quite a few things during this release cycle. We've detailed the big changes below, but we still advise that you give a quick read over the rest of the documentation as well.","title":"1.3.x to 1.4.x"},{"location":"migrating/1.4.0/#bot-creation-usage","text":"ExtensibleBot is no longer configured using constructor parameters - instead, it provides a builder-pattern DSL for you to use, which also allows you to configure Kord's cache and add extensions. For more information on what exactly you can configure, see the Bot concept page .","title":"Bot Creation &amp; Usage"},{"location":"migrating/1.4.0/#13x","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 val bot = ExtensibleBot ( addSentryExtension = false , handleSlashCommands = true , koinLogLevel = Level . DEBUG , prefix = \"!\" , // This is now the default prefix token = System . getenv ( \"TOKEN\" ), ) bot . addExtension ( :: TestExtension ) bot . start { intents { + Intents . all } presence { playing ( \"!help for command help\" ) } }","title":"1.3.x"},{"location":"migrating/1.4.0/#14x","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 val bot = ExtensibleBot ( env ( \"TOKEN\" ) !! ) { koinLogLevel = Level . DEBUG extensions { sentry = false add ( :: TestExtension ) } intents { + Intents . all } presence { playing ( \"!help for command help\" ) } slashCommands { enable = true } } bot . start () Additionally, the bot has gained the findExtension<T>() and findExtensions<T>() functions, allowing you to search for loaded extensions that match the given type - for example, to find the loaded extension that implements the new HelpProvider interface.","title":"1.4.x"},{"location":"migrating/1.4.0/#checks","text":"Additional checks have been added, along with support for the new interaction events that are made use of by slash commands. The newly-bundled checks allow you to ensure that users have (or do not have) specific permissions . All checks that concern specific entities have been rewritten to take either a DSL-style lambda that resolves to the entity, or a Snowflake that will later be resolved to that entity. This change has been made in order to allow extensions to be set up before the bot connects to Discord, and to improve extension registration times. For more information on this, see the checks concept page .","title":"Checks"},{"location":"migrating/1.4.0/#13x_1","text":"1 2 3 4 5 6 7 event < MessageCreateEvent > { check ( inGuild ( config . guild )) action { // ... } }","title":"1.3.x"},{"location":"migrating/1.4.0/#14x_1","text":"1 2 3 4 5 6 7 8 9 event < MessageCreateEvent > { // One or the other: check ( inGuild { config . guild }) check ( inGuild ( config . guildId )) action { // ... } }","title":"1.4.x"},{"location":"migrating/1.4.0/#commands","text":"In order to make room for slash commands, the commands system has had somewhat of an overhaul. This includes the following: Command and CommandContext have been rewritten and are now generic base classes. Message-based commands now use the MessageCommand and MessageCommandContext classes, and slash commands similarly make use of the SlashCommand and SlashCommandContext classes. The signature and parse functions used in command bodies have been removed. You can still set a custom signature string in the usual way, though, if you must - but this will result in a loss of information in some cases. To specify your Arguments subclass builder, you now pass it as the first parameter to the command , group or slashCommand function. This will automatically generate the command's signature, and the command's arguments will always be automatically parsed and placed within the arguments property of the current MessageCommandContext in the command's action body. ParseException has been renamed to CommandException , to better reflect the fact that you can throw it when you need to.","title":"Commands"},{"location":"migrating/1.4.0/#13x_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 command { name = \"post\" description = \"Create a post\" signature ( :: PostArguments ) action { // Option 1 val parsed = parse ( :: PostArguments ) message . respond ( \"** ${ parsed . title } ** (by ${ parsed . author . mention } )\\n\\n\" + parsed . body ) // Option 2 with ( parse ( :: PostArguments )) { message . respond ( \"** $ title ** (by ${ author . mention } )\\n\\n\" + body ) } } }","title":"1.3.x"},{"location":"migrating/1.4.0/#14x_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 command ( :: PostArguments ) { name = \"post\" description = \"Create a post\" action { // Option 1 message . respond ( \"** ${ arguments . title } ** (by ${ arguments . author . mention } )\\n\\n\" + arguments . body ) // Option 2 with ( arguments ) { message . respond ( \"** $ title ** (by ${ author . mention } )\\n\\n\" + body ) } } }","title":"1.4.x"},{"location":"migrating/1.4.0/#command-arguments-converters","text":"Some major changes have been made to arguments and converters as well, in order to facilitate slash commands and provide extra information in the command help output. All arguments defined in your Arguments subclasses require a description string. This should be a very short, human-readable string that explains what each argument is for. Argument descriptions are used in the bundled help extension, and they're shown on Discord as part of slash commands. Note that, for slash commands, optional arguments must always be specified as the last arguments for the command. Most converter types now implement the SlashCommandConverter interface, which provides the toSlashOption command. All converter types (aside from MultiConverter ) must implement this function, which makes the converter work as a slash command argument. As Discord's available argument types are lacking, please note that in many cases you'll want to tell Discord that your converter is a string converter. Parsing does not change for this purpose - you should continue to implement converters in the usual manner. Coalescing and optional converters now support an additional shouldThrow parameter. This parameter should be used to specify that the converter should throw an exception (which may be a CommandException ) when they fail to parse an argument from the list given to them. This is intended only for arguments that appear as the last argument in the list for a command, where the argument may be omitted but validation still needs to happen for its arguments. Defaulting converters do not support this parameter. Compiler errors (via opt-in annotations) have been added for converter functions that return a wrapped converter that changes the behaviour of the converter being wrapped. This has been done to try to help avoid problems caused by users directly making use of these functions instead of the relevant Arguments class extension functions, which can result in converters being filled incorrectly, the wrong converters being registered, and a myriad of other strange problems. If you're writing your own Arguments class extension functions, feel free to opt-in to these annotations at the file level. You'll need to be able to use these functions to write a full suite of extension functions for your own converters. NumberConverter has been replaced with IntConverter and LongConverter , in case you happen to need ints instead of longs. Please note that Discord only supports integer converters, even if you're using a LongConverter in your slash command arguments - you'll still get a Long , but it's not currently known whether slash commands can actually support numbers that large. All converters that support durations are now equipped with a nice long error message if the user supplies an invalid duration, which will be displayed as appropriate. If you'd rather stick with a short, single-line error, you can supply a false value for the new longHelp parameter for the relevant converter functions. The long error looks like this - the short error will simply use the first line: (for an invalid unit) Invalid duration unit specified: x (for a missing unit) Please specify a unit - bare numbers are not supported. How to use durations Durations are specified in pairs of amounts and units - for example, 12d would be 12 days. Compound durations are supported - for example, 2d12h would be 2 days and 12 hours. The following units are supported: Seconds: s , sec , second , seconds Minutes: m , mi , min , minute , minutes Hours: h , hour , hours Days: d , day , days Weeks: w , week , weeks Months: mo , month , months Years: y , year , years","title":"Command Arguments &amp; Converters"},{"location":"migrating/1.4.0/#example-argument-descriptions","text":"1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" , \"Post title\" ) // Single required Discord user argument val author by user ( \"author\" , \"User that this post should be attributed to\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" , \"Text content to be placed within the posts's body\" ) }","title":"Example: Argument descriptions"},{"location":"migrating/1.4.0/#example-toslashoption","text":"1 2 3 4 5 6 7 8 public class IntConverter ( private val radix : Int = 10 ) : SingleConverter < Int > () { // ... override suspend fun toSlashOption ( arg : Argument <*> ): OptionsBuilder = IntChoiceBuilder ( arg . displayName , arg . description ). apply { required = true } }","title":"Example: toSlashOption"},{"location":"migrating/1.4.0/#moved-converters","text":"Some converters have been moved to separate modules: Java Time : Duration (Java Time) with special-casing for coalescing conversion","title":"Moved Converters"},{"location":"migrating/1.4.0/#integrations","text":"An additional integration for Koin has been added. Koin is a lightweight service locator framework, written in pure Kotlin. It's been gaining in popularity due to its simplicity and low performance overhead, and we've decided to support it in order to make things easier to locate and work with. Koin is fully integrated, and you're expected to use it to retrieve references to different parts of the framework. For more information, we suggest you read the documentation for it .","title":"Integrations"},{"location":"migrating/1.4.0/#internationalisation-localisation","text":"KordEx now has full support for i18n! For more information, read the new i18n page .","title":"Internationalisation &amp; Localisation"},{"location":"migrating/1.4.0/#paginator","text":"For those of you that were making use of the included (but undocumented) Paginator class, it's been completely rewritten with support for page groups, embed formatting, dynamic footers, and several other features. As the original Paginator was undocumented (and not really meant to be used in production), we haven't written a specific migration guide for it. Instead, we suggest you read the documentation for it and rewrite your paginator usages to match the new API.","title":"Paginator"},{"location":"migrating/1.4.0/#provided-extensions","text":"Both of the bundled extensions have been updated to support the new KordEx features available in recent versions. Their package has also changed to make room for extension-specific interfaces. The HelpExtension has been updated to add support for command argument descriptions, using the richer page groups available in the rewritten paginator. You can click the reaction under help embeds to learn more about the displayed commands' arguments. Additionally, all custom help extensions must now implement the HelpProvider interface. This makes it easy for other extensions to, for example, display the help for their command when required. As slash commands (and their arguments) show their own help strings directly on Discord, the help extension does not support them. The SentryExtension has been updated to add a /feedback global slash command, which works just like the feedback message command. If an error occurs during processing of a slash command (and the Sentry extension is enabled), users will be prompted to make use of /feedback instead of the feedback message command.","title":"Provided Extensions"},{"location":"migrating/1.4.0/#scheduler","text":"The Scheduler class has been entirely rewritten, with a new Task abstraction class. For more information, you should read the Scheduler page .","title":"Scheduler"},{"location":"migrating/1.4.0/#utilities","text":"Many utilities have been created or rewritten during this release cycle. Instead of detailing each change here, we recommend you read the documentation for them .","title":"Utilities"},{"location":"modules/","text":"About \u00b6 Modules are separate projects that add functionality to Kord Extensions. Official modules are built alongside Kord Extensions and use the same versioning scheme - simply match the version of the module to the version of Kord Extensions you're using. Modules may provide anything, although additional converters for your command logic and fully-implemented extensions are the most common things to include.","title":"About"},{"location":"modules/#about","text":"Modules are separate projects that add functionality to Kord Extensions. Official modules are built alongside Kord Extensions and use the same versioning scheme - simply match the version of the module to the version of Kord Extensions you're using. Modules may provide anything, although additional converters for your command logic and fully-implemented extensions are the most common things to include.","title":"About"},{"location":"modules/common/","text":"Extra: Common \u00b6 The Common module provides shared code that is intended for use by other extensions, and extra extensions that provide additional services for other extensions to use. While this does make it largely a developer tool and library, users may also want to configure the bundled extensions. Provided Extensions \u00b6 EmojiExtension - keeps track of Discord custom emoji present on the bot's guilds, providing simple ways for other extensions to get at them (or default to something else if the emoji aren't available). Getting Started \u00b6 Maven repo: https://maven.kotlindiscord.com/repository/maven-public/ Maven coordinates: com.kotlindiscord.kord.extensions:extra-common:VERSION This module doesn't contain much that a user may need to interact with directly, but if you're using another module that makes use of one of the extensions in this one, you may need to configure them as explained below. As of this writing, none of the bundled extensions add any commands or user-facing components. At its simplest, you can add the extensions directly to your bot with no further configuration. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 suspend fun main () { val bot = ExtensibleBot ( env ( \"TOKEN\" ) !! ) { commands { defaultPrefix = \"!\" } extensions { extCommon { } } } bot . start () } Configuration: Emoji Extension \u00b6 Env var prefix: KORDEX_EMOJI System property prefix: kordex.emoji This extension makes use of the Konf library for configuration. Included in the JAR is a default configuration file, kordex/emoji/default.toml . You may configure the extension in one of the following ways: TOML file as a resource: kordex/emoji/config.toml TOML file on the filesystem: ./config/ext/emoji.toml Environment variables, prefixed with KORDEX_EMOJI_ , upper-casing keys and replacing . with _ in key names System properties, prefixed with kordex.emoji. For an example, feel free to read the included default.toml . The following configuration keys are available: emoji.guilds : List of guild IDs to index custom emoji from, if required - omit this or set it to an empty list and all guilds will be indexed, in the order the bot joined them in. emoji.overrides : Mapping of emoji names to guild IDs, if you need emoji with a specific name to come from a specific guild while ignoring the sorted list of indexed guilds. If you'd like to provide your own configuration adapter, implement the EmojiConfig interface in your own class. You can then register it in the builder when you set up your bot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 suspend fun main () { val bot = ExtensibleBot ( env ( \"TOKEN\" ) !! ) { commands { defaultPrefix = \"!\" } extensions { extCommon { emojiConfig = CustomEmojiConfig () } } } bot . start () } Abstract Classes \u00b6 This extension provides a number of abstract classes that you can use when developing your own extensions. TomlConfig \u00b6 The TomlConfig abstract class provides a set of functionality that allows extensions that can be configured to behave consistently, which makes things easier to understand for users. This extension makes use of the Konf library, to keep things concise. The class constructor takes the following arguments: Name Type Description baseName String Module/extension name in lowerCamelCase specs vararg: Spec All of the Konf Spec objects that should be loaded, in the order they should be loaded in resourcePrefix String Name for the resource group, \"kordex\" (by default) for all KordEx modules configFolder String Name for the inner config folder, \"ext\" (by default) for KordEx extension modules. configModifier Config.() Lambda that will be inserted into the Config object instantiation, if you need to customize it. This class takes the following steps to resolve a configuration, with the values from later steps overriding earlier ones: Look for $resourcePrefix/$baseName/default.toml in the JAR's resources (you should ship this with your module) Look for $resourcePrefix/$baseName/config.toml in the JAR's resources (users can provide this in their dist) Look for ./config/$configFolder/$baseName.toml on the filesystem (for users to write their own config files) Look for env vars prefixed with $resourcePrefix_$baseName , in ALL_CAPS Look for system properties prefixed with $resourcePrefix.$baseName. When extending this class, we recommend you create an interface containing getter functions that should return whatever values are required by your extension, to be implemented by your primary configuration class. This makes it easy to allow users to specify their own configuration classes for their own specific use-cases - for example, loading the configuration from a database. Here's an example of one way you can do this: MyConfigSpec 1 2 3 4 object MyConfigSpec : ConfigSpec () { val enabled by required < Boolean > () val guild by required < Snowflake > () } MyConfigAdapter 1 2 3 4 interface MyConfigAdapter { suspend fun isEnabled (): Boolean suspend fun getGuild (): Snowflake } MyTomlConfig 1 2 3 4 class MyTomlConfig : MyConfigAdapter , TomlConfig ( \"my\" , MyConfigSpec ) { override suspend fun isEnabled (): Boolean = config [ MyConfigSpec . enabled ] override suspend fun getGuild (): Snowflake = config [ MyConfigSpec . guild ] } SerializedData \u00b6 The SerializedData abstract class provides a set of functionality that allows you to serialize (and deserialize) data (generally, extension state) to disk. This class makes use of kotlinx.serialization , and can be customized for different formats. The class constructor takes the following arguments: Name Type Description T TypeVar: Any Type of the class you plan to serialize. baseName String Filename, excluding extension. dataFolder String Folder within the ./data folder to place the file within. serializerObj KSerializer<T> Serializer for your data class - pass serializer() if you don't have a custom one. defaultBuilder () -> T Builder function or lambda that creates a new instance of your data class, with defaults set up. If all of the parameters in your data class have default values, you can pass the constructor using ::T instead. fileExtension String File extension, defaulting to \"json\" - if you're using a custom format, you can change this in your subclass. By default, this class assumes you want to use JSON, and will serialize to JSON files on disk. You can change this behaviour in your subclasses by overriding the decode and encode functions and changing the fileExtension constructor parameter. This class saves data in ./data/$dataFolder/$baseName.$fileExtension . You always need to provide the baseName and dataFolder parameters, but fileExtension will default to \"json\" if you don't set it. We recommend providing these as part of the superclass invocation rather than as constructor parameters in your subclass, if that's appropriate. If the file doesn't exist or is empty, then it will automatically be filled with the data class created by the defaultBuilder function at load time. Deserialization errors will not result in the file being overwritten with default data, you'll need to handle that yourself if it's what you need. Saving Data Note: You will need to manually call the save and load functions. For example, if your data class tracks an enabled value, you should implement either a getEnabled() and setEnabled(bool) function, or a val with custom getters and setters - but both options must call save as appropriate when data is modified! When extending this class, we recommend you create an interface containing getter and setter functions that should interface with the data property, to be implemented by your primary data serialization class. This makes it easy to allow users to specify their own serialization classes for their own specific use-cases - for example, loading the data from a database, and writing it back. Here's an example of one way you can do this: MyData 1 2 3 4 5 @Serializable data class MyData ( var enabled : Boolean = true , var guild : Snowflake? = null ) MyDataAdapter 1 2 3 4 5 6 7 interface MyDataAdapter { suspend fun isEnabled (): Boolean suspend fun setEnabled ( value : Boolean ) suspend fun getGuild (): Snowflake suspend fun setGuild ( value : Snowflake ) } MyJsonData 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyJsonData : MyDataAdapter , SerializedData < MyData > ( \"data\" , \"my\" , serializer (), :: MyData ) { init { load () } override suspend fun isEnabled (): Boolean = data . enabled override suspend fun getGuild (): Snowflake = data . guild override suspend fun setEnabled ( value : Boolean ) { data . enabled = value save () } override suspend fun setGuild ( value : Snowflake ) { data . guild = value save () } }","title":"Extra: Common"},{"location":"modules/common/#extra-common","text":"The Common module provides shared code that is intended for use by other extensions, and extra extensions that provide additional services for other extensions to use. While this does make it largely a developer tool and library, users may also want to configure the bundled extensions.","title":"Extra: Common"},{"location":"modules/common/#provided-extensions","text":"EmojiExtension - keeps track of Discord custom emoji present on the bot's guilds, providing simple ways for other extensions to get at them (or default to something else if the emoji aren't available).","title":"Provided Extensions"},{"location":"modules/common/#getting-started","text":"Maven repo: https://maven.kotlindiscord.com/repository/maven-public/ Maven coordinates: com.kotlindiscord.kord.extensions:extra-common:VERSION This module doesn't contain much that a user may need to interact with directly, but if you're using another module that makes use of one of the extensions in this one, you may need to configure them as explained below. As of this writing, none of the bundled extensions add any commands or user-facing components. At its simplest, you can add the extensions directly to your bot with no further configuration. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 suspend fun main () { val bot = ExtensibleBot ( env ( \"TOKEN\" ) !! ) { commands { defaultPrefix = \"!\" } extensions { extCommon { } } } bot . start () }","title":"Getting Started"},{"location":"modules/common/#configuration-emoji-extension","text":"Env var prefix: KORDEX_EMOJI System property prefix: kordex.emoji This extension makes use of the Konf library for configuration. Included in the JAR is a default configuration file, kordex/emoji/default.toml . You may configure the extension in one of the following ways: TOML file as a resource: kordex/emoji/config.toml TOML file on the filesystem: ./config/ext/emoji.toml Environment variables, prefixed with KORDEX_EMOJI_ , upper-casing keys and replacing . with _ in key names System properties, prefixed with kordex.emoji. For an example, feel free to read the included default.toml . The following configuration keys are available: emoji.guilds : List of guild IDs to index custom emoji from, if required - omit this or set it to an empty list and all guilds will be indexed, in the order the bot joined them in. emoji.overrides : Mapping of emoji names to guild IDs, if you need emoji with a specific name to come from a specific guild while ignoring the sorted list of indexed guilds. If you'd like to provide your own configuration adapter, implement the EmojiConfig interface in your own class. You can then register it in the builder when you set up your bot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 suspend fun main () { val bot = ExtensibleBot ( env ( \"TOKEN\" ) !! ) { commands { defaultPrefix = \"!\" } extensions { extCommon { emojiConfig = CustomEmojiConfig () } } } bot . start () }","title":"Configuration: Emoji Extension"},{"location":"modules/common/#abstract-classes","text":"This extension provides a number of abstract classes that you can use when developing your own extensions.","title":"Abstract Classes"},{"location":"modules/common/#tomlconfig","text":"The TomlConfig abstract class provides a set of functionality that allows extensions that can be configured to behave consistently, which makes things easier to understand for users. This extension makes use of the Konf library, to keep things concise. The class constructor takes the following arguments: Name Type Description baseName String Module/extension name in lowerCamelCase specs vararg: Spec All of the Konf Spec objects that should be loaded, in the order they should be loaded in resourcePrefix String Name for the resource group, \"kordex\" (by default) for all KordEx modules configFolder String Name for the inner config folder, \"ext\" (by default) for KordEx extension modules. configModifier Config.() Lambda that will be inserted into the Config object instantiation, if you need to customize it. This class takes the following steps to resolve a configuration, with the values from later steps overriding earlier ones: Look for $resourcePrefix/$baseName/default.toml in the JAR's resources (you should ship this with your module) Look for $resourcePrefix/$baseName/config.toml in the JAR's resources (users can provide this in their dist) Look for ./config/$configFolder/$baseName.toml on the filesystem (for users to write their own config files) Look for env vars prefixed with $resourcePrefix_$baseName , in ALL_CAPS Look for system properties prefixed with $resourcePrefix.$baseName. When extending this class, we recommend you create an interface containing getter functions that should return whatever values are required by your extension, to be implemented by your primary configuration class. This makes it easy to allow users to specify their own configuration classes for their own specific use-cases - for example, loading the configuration from a database. Here's an example of one way you can do this: MyConfigSpec 1 2 3 4 object MyConfigSpec : ConfigSpec () { val enabled by required < Boolean > () val guild by required < Snowflake > () } MyConfigAdapter 1 2 3 4 interface MyConfigAdapter { suspend fun isEnabled (): Boolean suspend fun getGuild (): Snowflake } MyTomlConfig 1 2 3 4 class MyTomlConfig : MyConfigAdapter , TomlConfig ( \"my\" , MyConfigSpec ) { override suspend fun isEnabled (): Boolean = config [ MyConfigSpec . enabled ] override suspend fun getGuild (): Snowflake = config [ MyConfigSpec . guild ] }","title":"TomlConfig"},{"location":"modules/common/#serializeddata","text":"The SerializedData abstract class provides a set of functionality that allows you to serialize (and deserialize) data (generally, extension state) to disk. This class makes use of kotlinx.serialization , and can be customized for different formats. The class constructor takes the following arguments: Name Type Description T TypeVar: Any Type of the class you plan to serialize. baseName String Filename, excluding extension. dataFolder String Folder within the ./data folder to place the file within. serializerObj KSerializer<T> Serializer for your data class - pass serializer() if you don't have a custom one. defaultBuilder () -> T Builder function or lambda that creates a new instance of your data class, with defaults set up. If all of the parameters in your data class have default values, you can pass the constructor using ::T instead. fileExtension String File extension, defaulting to \"json\" - if you're using a custom format, you can change this in your subclass. By default, this class assumes you want to use JSON, and will serialize to JSON files on disk. You can change this behaviour in your subclasses by overriding the decode and encode functions and changing the fileExtension constructor parameter. This class saves data in ./data/$dataFolder/$baseName.$fileExtension . You always need to provide the baseName and dataFolder parameters, but fileExtension will default to \"json\" if you don't set it. We recommend providing these as part of the superclass invocation rather than as constructor parameters in your subclass, if that's appropriate. If the file doesn't exist or is empty, then it will automatically be filled with the data class created by the defaultBuilder function at load time. Deserialization errors will not result in the file being overwritten with default data, you'll need to handle that yourself if it's what you need. Saving Data Note: You will need to manually call the save and load functions. For example, if your data class tracks an enabled value, you should implement either a getEnabled() and setEnabled(bool) function, or a val with custom getters and setters - but both options must call save as appropriate when data is modified! When extending this class, we recommend you create an interface containing getter and setter functions that should interface with the data property, to be implemented by your primary data serialization class. This makes it easy to allow users to specify their own serialization classes for their own specific use-cases - for example, loading the data from a database, and writing it back. Here's an example of one way you can do this: MyData 1 2 3 4 5 @Serializable data class MyData ( var enabled : Boolean = true , var guild : Snowflake? = null ) MyDataAdapter 1 2 3 4 5 6 7 interface MyDataAdapter { suspend fun isEnabled (): Boolean suspend fun setEnabled ( value : Boolean ) suspend fun getGuild (): Snowflake suspend fun setGuild ( value : Snowflake ) } MyJsonData 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyJsonData : MyDataAdapter , SerializedData < MyData > ( \"data\" , \"my\" , serializer (), :: MyData ) { init { load () } override suspend fun isEnabled (): Boolean = data . enabled override suspend fun getGuild (): Snowflake = data . guild override suspend fun setEnabled ( value : Boolean ) { data . enabled = value save () } override suspend fun setGuild ( value : Snowflake ) { data . guild = value save () } }","title":"SerializedData"},{"location":"modules/java-time/","text":"Java Time \u00b6 The Java Time module provides converters and parsers that allow you to work with Java 8 Durations in your commands. This used to be the standard Duration converter, but was split out into a module as some users didn't need it. Getting Started \u00b6 Maven repo: https://maven.kotlindiscord.com/repository/maven-public/ Maven coordinates: com.kotlindiscord.kord.extensions:java-time:VERSION 1 2 3 4 5 6 val kordExVersion : String by project dependencies { implementation ( \"com.kotlindiscord.kord.extensions:kord-extensions: $ kordExVersion \" ) implementation ( \"com.kotlindiscord.kord.extensions:java-time: $ kordExVersion \" ) } Converters \u00b6 The following converters are included: J8DurationCoalescingConverter J8DurationConverter These can be added to your Arguments objects using the following functions: coalescedJ8Duration defaultingCoalescedJ8Duration defaultingJ8Duration j8DurationList j8Duration optionalCoalescedJ8Duration optionalJ8Duration Utilities \u00b6 Function Description ChronoContainer .toHuman For a ChronoContainer, return a human-readable string formatted for the given locale Instant .toDiscord For a Java Instant, return the Discord auto-formatted String for the given TimestampType","title":"Java Time"},{"location":"modules/java-time/#java-time","text":"The Java Time module provides converters and parsers that allow you to work with Java 8 Durations in your commands. This used to be the standard Duration converter, but was split out into a module as some users didn't need it.","title":"Java Time"},{"location":"modules/java-time/#getting-started","text":"Maven repo: https://maven.kotlindiscord.com/repository/maven-public/ Maven coordinates: com.kotlindiscord.kord.extensions:java-time:VERSION 1 2 3 4 5 6 val kordExVersion : String by project dependencies { implementation ( \"com.kotlindiscord.kord.extensions:kord-extensions: $ kordExVersion \" ) implementation ( \"com.kotlindiscord.kord.extensions:java-time: $ kordExVersion \" ) }","title":"Getting Started"},{"location":"modules/java-time/#converters","text":"The following converters are included: J8DurationCoalescingConverter J8DurationConverter These can be added to your Arguments objects using the following functions: coalescedJ8Duration defaultingCoalescedJ8Duration defaultingJ8Duration j8DurationList j8Duration optionalCoalescedJ8Duration optionalJ8Duration","title":"Converters"},{"location":"modules/java-time/#utilities","text":"Function Description ChronoContainer .toHuman For a ChronoContainer, return a human-readable string formatted for the given locale Instant .toDiscord For a Java Instant, return the Discord auto-formatted String for the given TimestampType","title":"Utilities"},{"location":"modules/mappings/","text":"Minecraft Mappings \u00b6","title":"Minecraft Mappings"},{"location":"modules/mappings/#minecraft-mappings","text":"","title":"Minecraft Mappings"},{"location":"modules/time4j/","text":"Time4J \u00b6 The Time4J module provides converters and parsers that allow you to work with Time4J Durations in your commands. Getting Started \u00b6 Maven repo: https://maven.kotlindiscord.com/repository/maven-public/ Maven coordinates: com.kotlindiscord.kord.extensions:time4j:VERSION 1 2 3 4 5 6 val kordExVersion : String by project dependencies { implementation ( \"com.kotlindiscord.kord.extensions:kord-extensions: $ kordExVersion \" ) implementation ( \"com.kotlindiscord.kord.extensions:time4j: $ kordExVersion \" ) } Note: Be sure to call TZDATA.init() before your bot starts up, or you'll get lots of errors! Converters \u00b6 The following converters are included: T4JDurationCoalescingConverter T4JDurationConverter These can be added to your Arguments objects using the following functions: coalescedT4jDuration defaultingCoalescedT4jDuration defaultingT4jDuration t4jDurationList t4jDuration optionalCoalescedT4jDuration optionalT4jDuration Utilities \u00b6 Function Description Duration .toHuman For a Time4J Duration, return a human-readable string formatted for the given locale GeneralTimestamp<*>.toDiscord For a Time4J GeneralTimestamp, return the Discord auto-formatted String for the given TimestampType at UTC, with the day starting at midnight Moment.toDiscord For a Time4J Moment, return the Discord auto-formatted String for the given TimestampType PlainTimestamp.toDiscord For a Time4J PlainTimestamp, return the Discord auto-formatted String for the given TimestampType at UTC","title":"Time4J"},{"location":"modules/time4j/#time4j","text":"The Time4J module provides converters and parsers that allow you to work with Time4J Durations in your commands.","title":"Time4J"},{"location":"modules/time4j/#getting-started","text":"Maven repo: https://maven.kotlindiscord.com/repository/maven-public/ Maven coordinates: com.kotlindiscord.kord.extensions:time4j:VERSION 1 2 3 4 5 6 val kordExVersion : String by project dependencies { implementation ( \"com.kotlindiscord.kord.extensions:kord-extensions: $ kordExVersion \" ) implementation ( \"com.kotlindiscord.kord.extensions:time4j: $ kordExVersion \" ) } Note: Be sure to call TZDATA.init() before your bot starts up, or you'll get lots of errors!","title":"Getting Started"},{"location":"modules/time4j/#converters","text":"The following converters are included: T4JDurationCoalescingConverter T4JDurationConverter These can be added to your Arguments objects using the following functions: coalescedT4jDuration defaultingCoalescedT4jDuration defaultingT4jDuration t4jDurationList t4jDuration optionalCoalescedT4jDuration optionalT4jDuration","title":"Converters"},{"location":"modules/time4j/#utilities","text":"Function Description Duration .toHuman For a Time4J Duration, return a human-readable string formatted for the given locale GeneralTimestamp<*>.toDiscord For a Time4J GeneralTimestamp, return the Discord auto-formatted String for the given TimestampType at UTC, with the day starting at midnight Moment.toDiscord For a Time4J Moment, return the Discord auto-formatted String for the given TimestampType PlainTimestamp.toDiscord For a Time4J PlainTimestamp, return the Discord auto-formatted String for the given TimestampType at UTC","title":"Utilities"},{"location":"utilities/components/","text":"Components \u00b6 To provide an integrated API for working with Discord's buttons (and other components going forward), Kord Extensions provides a simple DSL builder for adding components to your messages. This should be sufficient for most use-cases, but you can always extend the Components class or write your own component handling if you need to. Components DSL \u00b6 To get started, create a message or follow-up and invoke the components DSL function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ephemeralFollowUp { content = \"Buttons!\" components ( 60 ) { // A timeout of 60 seconds, optional interactiveButton { label = \"Button one!\" // Style defaults to `Primary` action { // Easy button actions respond ( \"Button one pressed!\" ) } } interactiveButton { label = \"Button two!\" style = ButtonStyle . Secondary action { respond ( \"Button two pressed!\" ) } } disabledButton { // Labels are optional if you have an emoji emoji ( \"\u274e\" ) // Easily add an emoji from various sources } linkButton { label = \"Google\" // You can provide both a label and emoji if you like emoji ( \"\ud83d\udd17\" ) url = \"https://google.com\" } } } This will automatically sort all the components you've provided into rows (provided you have 25 or less), send them to Discord, and set up event handlers to call their actions as required. Sorting behaviour and empty rows All messages may have up to 5 rows of components, and each row may contain up to 5 components. For buttons that don't have a row provided, the Components class will attempt to pack the components into each row that has space, in order. If you provide two components on the first row and three on the second, unsorted components will try to fill in the empty space in those rows before moving onto the latter rows. Components are always sorted from the first row to the last. If you want to avoid automatic sorting, then simply provide a specific row for each of your components. Empty rows are also skipped when adding components to your message, so you can provide five components on the last row and allow the Components class to sort everything else above them. The components DSL function will return the Components object that contains all the components you just defined, and handles their actions. If you didn't set a timeout or would like to trigger it early, you can call the stop() function, and your bot will stop listening for component actions. Common Functionality \u00b6 All component functions take the following parameters, in addition to the DSL function body: Parameter Type Description row Int? Optionally, provide a row (from 1-4) to append the component to that row directly. Button Properties \u00b6 The following properties are common to all button types. As usual, properties marked with are required, but may not be if you provide another property. Parameter Type Description label String? The button's label - required if no emoji was provided. partialEmoji DiscordPartial Emoji? The button's emoji - required if no label was provided. You'll probably want to use one of the emoji functions instead of setting this directly. Button Functions \u00b6 The following functions are common to all button types. Function Description emoji A convenience function that will set the button's partialEmoji property based on a given Unicode emoji, guild custom emoji or reaction emoji. Disabled Buttons \u00b6 Disabled buttons don't do anything when clicked. Their builders have the following properties, with required properties marked with : Parameter Type Description id String The button's unique ID on Discord, which defaults to a randomly-generated UUID. Normally this would be used for click actions, but disabled buttons don't have one! style Button Style The button's style on Discord, which defaults to Primary . Interactive Buttons \u00b6 Interactive buttons have a click action that's handled by the bot. Their builders have the following properties, with required properties marked with : Parameter Type Description ackType AutoAck Type? If the button isn't being sent as part of a slash command interaction, then this will be used for the automatic acknowledgement - just like it would be for slash commands. Defaults to EPHEMERAL if you're working within a slash command, and PUBLIC if you're working with normal messages. Disable with null . deferredAck Boolean Set this to true to send a deferred acknowledgement instead of a normal one, which will clear the \"processing\" state of the button interaction. This is false by default, which will wait for you to send a followUp before clearing the \"processing\" state. followParent Boolean By default, button interactions that happen as part of a slash command follow the ack type of that slash command's context. If you don't want that, then set this to false . id String The button's unique ID on Discord, which defaults to a randomly-generated UUID. Normally this would be used for click actions, but disabled buttons don't have one! style Button Style The button's style on Discord, which defaults to Primary . Additionally, the following functions are available, with functions that must be called marked with : Function Description action Set the action to be taken when this button is clicked. All interactive button actions are treated as receiver functions to an InteractiveButtonContext object. check Provide a check lambda or callable which must pass for the button action to be run. If a check fails, the interaction will be acknowledged with a deferred ack - meaning the \"processing\" status will be cleared - and the action will not be called. Interactive button contexts The InteractiveButtonContext class provides the execution context for your button's click actions. It largely provides the same properties and functions that the SlashCommandContext object does, with the addition of components and interaction , which represent the relevant Components container and properly-typed ComponentInteraction object respectively. Link Buttons \u00b6 Interactive buttons direct the user to a URL when clicked. Their builders have the following properties, with required properties marked with : Parameter Type Description id String The button's unique ID on Discord, which defaults to a randomly-generated UUID. Normally this would be used for click actions, but disabled buttons don't have one! style Button Style The button's style on Discord, which defaults to Primary . url String The URL to direct the user to. Tracking buttons between restarts \u00b6 While the Components object doesn't provide any specific tracking for component actions after the bot has been restarted, you can implement this yourself with relative ease. Each of the component functions (eg, interactiveButton() ) return the builder object used. You can store the ID of the component used here for later. When the bot restarts, you can load your stored IDs and create new Components objects for the components for each message. Store the action for each UUID into the Components object using the relevant map - for example, interactiveActions for interactive button actions. Finally, call the startListening function with the desired timeout, and your component actions should be functional again.","title":"Components"},{"location":"utilities/components/#components","text":"To provide an integrated API for working with Discord's buttons (and other components going forward), Kord Extensions provides a simple DSL builder for adding components to your messages. This should be sufficient for most use-cases, but you can always extend the Components class or write your own component handling if you need to.","title":"Components"},{"location":"utilities/components/#components-dsl","text":"To get started, create a message or follow-up and invoke the components DSL function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ephemeralFollowUp { content = \"Buttons!\" components ( 60 ) { // A timeout of 60 seconds, optional interactiveButton { label = \"Button one!\" // Style defaults to `Primary` action { // Easy button actions respond ( \"Button one pressed!\" ) } } interactiveButton { label = \"Button two!\" style = ButtonStyle . Secondary action { respond ( \"Button two pressed!\" ) } } disabledButton { // Labels are optional if you have an emoji emoji ( \"\u274e\" ) // Easily add an emoji from various sources } linkButton { label = \"Google\" // You can provide both a label and emoji if you like emoji ( \"\ud83d\udd17\" ) url = \"https://google.com\" } } } This will automatically sort all the components you've provided into rows (provided you have 25 or less), send them to Discord, and set up event handlers to call their actions as required. Sorting behaviour and empty rows All messages may have up to 5 rows of components, and each row may contain up to 5 components. For buttons that don't have a row provided, the Components class will attempt to pack the components into each row that has space, in order. If you provide two components on the first row and three on the second, unsorted components will try to fill in the empty space in those rows before moving onto the latter rows. Components are always sorted from the first row to the last. If you want to avoid automatic sorting, then simply provide a specific row for each of your components. Empty rows are also skipped when adding components to your message, so you can provide five components on the last row and allow the Components class to sort everything else above them. The components DSL function will return the Components object that contains all the components you just defined, and handles their actions. If you didn't set a timeout or would like to trigger it early, you can call the stop() function, and your bot will stop listening for component actions.","title":"Components DSL"},{"location":"utilities/components/#common-functionality","text":"All component functions take the following parameters, in addition to the DSL function body: Parameter Type Description row Int? Optionally, provide a row (from 1-4) to append the component to that row directly.","title":"Common Functionality"},{"location":"utilities/components/#button-properties","text":"The following properties are common to all button types. As usual, properties marked with are required, but may not be if you provide another property. Parameter Type Description label String? The button's label - required if no emoji was provided. partialEmoji DiscordPartial Emoji? The button's emoji - required if no label was provided. You'll probably want to use one of the emoji functions instead of setting this directly.","title":"Button Properties"},{"location":"utilities/components/#button-functions","text":"The following functions are common to all button types. Function Description emoji A convenience function that will set the button's partialEmoji property based on a given Unicode emoji, guild custom emoji or reaction emoji.","title":"Button Functions"},{"location":"utilities/components/#disabled-buttons","text":"Disabled buttons don't do anything when clicked. Their builders have the following properties, with required properties marked with : Parameter Type Description id String The button's unique ID on Discord, which defaults to a randomly-generated UUID. Normally this would be used for click actions, but disabled buttons don't have one! style Button Style The button's style on Discord, which defaults to Primary .","title":"Disabled Buttons"},{"location":"utilities/components/#interactive-buttons","text":"Interactive buttons have a click action that's handled by the bot. Their builders have the following properties, with required properties marked with : Parameter Type Description ackType AutoAck Type? If the button isn't being sent as part of a slash command interaction, then this will be used for the automatic acknowledgement - just like it would be for slash commands. Defaults to EPHEMERAL if you're working within a slash command, and PUBLIC if you're working with normal messages. Disable with null . deferredAck Boolean Set this to true to send a deferred acknowledgement instead of a normal one, which will clear the \"processing\" state of the button interaction. This is false by default, which will wait for you to send a followUp before clearing the \"processing\" state. followParent Boolean By default, button interactions that happen as part of a slash command follow the ack type of that slash command's context. If you don't want that, then set this to false . id String The button's unique ID on Discord, which defaults to a randomly-generated UUID. Normally this would be used for click actions, but disabled buttons don't have one! style Button Style The button's style on Discord, which defaults to Primary . Additionally, the following functions are available, with functions that must be called marked with : Function Description action Set the action to be taken when this button is clicked. All interactive button actions are treated as receiver functions to an InteractiveButtonContext object. check Provide a check lambda or callable which must pass for the button action to be run. If a check fails, the interaction will be acknowledged with a deferred ack - meaning the \"processing\" status will be cleared - and the action will not be called. Interactive button contexts The InteractiveButtonContext class provides the execution context for your button's click actions. It largely provides the same properties and functions that the SlashCommandContext object does, with the addition of components and interaction , which represent the relevant Components container and properly-typed ComponentInteraction object respectively.","title":"Interactive Buttons"},{"location":"utilities/components/#link-buttons","text":"Interactive buttons direct the user to a URL when clicked. Their builders have the following properties, with required properties marked with : Parameter Type Description id String The button's unique ID on Discord, which defaults to a randomly-generated UUID. Normally this would be used for click actions, but disabled buttons don't have one! style Button Style The button's style on Discord, which defaults to Primary . url String The URL to direct the user to.","title":"Link Buttons"},{"location":"utilities/components/#tracking-buttons-between-restarts","text":"While the Components object doesn't provide any specific tracking for component actions after the bot has been restarted, you can implement this yourself with relative ease. Each of the component functions (eg, interactiveButton() ) return the builder object used. You can store the ID of the component used here for later. When the bot restarts, you can load your stored IDs and create new Components objects for the components for each message. Store the action for each UUID into the Components object using the relevant map - for example, interactiveActions for interactive button actions. Finally, call the startListening function with the desired timeout, and your component actions should be functional again.","title":"Tracking buttons between restarts"},{"location":"utilities/general/","text":"General \u00b6 To make your life easier, Kord Extensions contains a number of utilities. These utilities have been categorized by type, to make things easier to find. Why not PR these to Kord? At its core, Kord is a protocol library and caching implementation. It's designed to follow Discord's API spec as close as it can and, while it does provide many niceties, not every utility makes sense to include directly within Kord. If you feel like that's not the way things should be, please have a chat with the Kord team - we're always working with them and we'll happily share whatever utilities they feel should be upstream! Attachments \u00b6 Function Description Attachment.download Downloads the attachment to a ByteBuffer and returns it - note that this will load the entire file into memory, so you should use one of the other functions if you just want to write it to a file Attachment.downloadToFile Downloads the attachment to the given file, returning the corresponding [Path] object Attachment.downloadToFolder Downloads the attachment to a file within the given directory, returning the corresponding [Path] object Channels \u00b6 Function Description ensureWebhook Ensures that a webhook with the given parameters exists in a channel, and returns it for use Deltas \u00b6 Kord itself doesn't contain any real way to compare two events or objects, so Kord Extensions includes some deltas you can use to find the difference between certain objects. UserDelta for comparing two base User objects MemberDelta for comparing two guild Member objects MessageDelta for comparing two Message objects RoleDelta for comparing the roles between two guild Member objects In all cases, you should use the static from function to create a delta object. All properties on delta objects are Kord Optional s - they'll be set to Optional.Missing if there was no change between the two objects, otherwise they'll contain the newly changed value. If the from function returns null , then the old object you passed as the first parameter is also null . You'll also get null from RoleDelta.from() if there were no changes. Environment \u00b6 Function Description env Get the value for an environmental variable (if it exists), attempting to load from a .env file in the current working directory first. Koin \u00b6 Function Description getKoin For situations where you can't inherit the KoinComponent interface (for example, in a top-level function), you can use this function to get the current Koin instance. loadModule Wrapper around Koin's module DSL function that immediately registers the module against the current Koin instance. Kord \u00b6 Property Description Kord.users Quick access to a Flow containing all Kord User objects that are in the cache Function Description Kord.waitFor Simple function for waiting for a specific Kord event, with a timeout KordLiveEntity.waitFor Simple function for waiting for a specific Kord event that refers to the given live entity, with a timeout Members \u00b6 Function Description Member.hasRole Checks whether a guild member has the given role Member.hasRoles Checks whether a guild member all of the given roles Member.hasPermission Checks whether a guild member has the given permission at guild level Member.hasPermissions Checks whether a guild member all of the given permissions at guild level Member.getTopRole Returns the guild member's top role, or null if they don't have a role Messages \u00b6 Property Description MessageData.authorId Quick access to the message author's ID MessageData.authorIsBot Quick access to check whether the message author is a bot Message.isCrossPost Whether this message was sent from a different guild's followed announcement channel Message.isEphemeral Whether this is an ephemeral message from the Interactions system Message.isPublished Whether this message was published to the guilds that are following its channel Message.isUrgent Whether this message came from Discord's urgent message system Message.originalMessageDeleted When isCrossPost , whether the source message has been deleted from the original guild Message.suppressEmbeds Whether this message's embeds should be serialized Function Description Message.addReaction Convenience function to add a Unicode emoji reaction represented by a string to the message Message.deleteReaction Convenience function to remove a Unicode emoji reaction represented by a string or other relevant object from the message Message.deleteOwnReaction Convenience function to remove a reaction from the message that was previously added by the bot Message.deleteIgnoringNotFound Convenience function to delete a message and ignore any errors if the message no longer exists Message.delete Convenience function to delete a message after a delay, which does not block the current coroutine or thread Message.getUrl Convenience function to construct the URL for a message Message.parse Parses message content into a list using an Apache Commons StringTokenizer , which supports quotes for individual values with spaces Message.requireChannel Function that ensures a message was sent within a given channel (with some options), responding with an error if not Message.requireGuildChannel Function that ensures a message was not sent privately (with some options), responding with an error if it was Message.respond Convenience function to respond to a user's message, with the option to use either Discord's replies feature or just a mention Misc \u00b6 Function Description runSuspended Convenience function to run a block of code in a coroutine dispatcher, defaulting to Dispatchers.IO - useful for otherwise blocking calls Reaction \u00b6 This utility transforms other types to ReactionEmoji objects. Function Description GuildEmoji.toReaction Transform the given GuildEmoji object into a ReactionEmoji object String.toReaction Transform a String object containing a Unicode emoji into a ReactionEmoji object RestRequest \u00b6 This utility concerns Ktor's RestRequestException objects. Function Description RestRequestException.hasStatus Check whether the given exception concerns a specific HttpStatusCode RestRequestException.hasStatusCode Check whether the given exception concerns a specific HTTP status code integer RestRequestException.hasNotStatus Check whether the given exception does not concern a specific HttpStatusCode RestRequestException.hasNotStatusCode Check whether the given exception does not concern a specific HTTP status code integer String \u00b6 Function Description String.parseBoolean Parses a String into a Boolean based on its starting character and the locale for the given context (or a given locale) String.splitOn Splits a string into a Pair containing the characters matching the predicate up until its first failure, and the rest of the string Users \u00b6 Property Description User.createdAt Quick access to a user's creation time, taken from their Snowflake User.profileLink Quick access to a user's profile URL Function Description User.dm Send a private message to a user, returning a Message object if successfull or null if the user has their private messages disabled topRole Retrieve a user's top role, given a guild's Snowflake User?.isNullOrBot Check whether the given User object is null, or a bot","title":"General"},{"location":"utilities/general/#general","text":"To make your life easier, Kord Extensions contains a number of utilities. These utilities have been categorized by type, to make things easier to find. Why not PR these to Kord? At its core, Kord is a protocol library and caching implementation. It's designed to follow Discord's API spec as close as it can and, while it does provide many niceties, not every utility makes sense to include directly within Kord. If you feel like that's not the way things should be, please have a chat with the Kord team - we're always working with them and we'll happily share whatever utilities they feel should be upstream!","title":"General"},{"location":"utilities/general/#attachments","text":"Function Description Attachment.download Downloads the attachment to a ByteBuffer and returns it - note that this will load the entire file into memory, so you should use one of the other functions if you just want to write it to a file Attachment.downloadToFile Downloads the attachment to the given file, returning the corresponding [Path] object Attachment.downloadToFolder Downloads the attachment to a file within the given directory, returning the corresponding [Path] object","title":"Attachments"},{"location":"utilities/general/#channels","text":"Function Description ensureWebhook Ensures that a webhook with the given parameters exists in a channel, and returns it for use","title":"Channels"},{"location":"utilities/general/#deltas","text":"Kord itself doesn't contain any real way to compare two events or objects, so Kord Extensions includes some deltas you can use to find the difference between certain objects. UserDelta for comparing two base User objects MemberDelta for comparing two guild Member objects MessageDelta for comparing two Message objects RoleDelta for comparing the roles between two guild Member objects In all cases, you should use the static from function to create a delta object. All properties on delta objects are Kord Optional s - they'll be set to Optional.Missing if there was no change between the two objects, otherwise they'll contain the newly changed value. If the from function returns null , then the old object you passed as the first parameter is also null . You'll also get null from RoleDelta.from() if there were no changes.","title":"Deltas"},{"location":"utilities/general/#environment","text":"Function Description env Get the value for an environmental variable (if it exists), attempting to load from a .env file in the current working directory first.","title":"Environment"},{"location":"utilities/general/#koin","text":"Function Description getKoin For situations where you can't inherit the KoinComponent interface (for example, in a top-level function), you can use this function to get the current Koin instance. loadModule Wrapper around Koin's module DSL function that immediately registers the module against the current Koin instance.","title":"Koin"},{"location":"utilities/general/#kord","text":"Property Description Kord.users Quick access to a Flow containing all Kord User objects that are in the cache Function Description Kord.waitFor Simple function for waiting for a specific Kord event, with a timeout KordLiveEntity.waitFor Simple function for waiting for a specific Kord event that refers to the given live entity, with a timeout","title":"Kord"},{"location":"utilities/general/#members","text":"Function Description Member.hasRole Checks whether a guild member has the given role Member.hasRoles Checks whether a guild member all of the given roles Member.hasPermission Checks whether a guild member has the given permission at guild level Member.hasPermissions Checks whether a guild member all of the given permissions at guild level Member.getTopRole Returns the guild member's top role, or null if they don't have a role","title":"Members"},{"location":"utilities/general/#messages","text":"Property Description MessageData.authorId Quick access to the message author's ID MessageData.authorIsBot Quick access to check whether the message author is a bot Message.isCrossPost Whether this message was sent from a different guild's followed announcement channel Message.isEphemeral Whether this is an ephemeral message from the Interactions system Message.isPublished Whether this message was published to the guilds that are following its channel Message.isUrgent Whether this message came from Discord's urgent message system Message.originalMessageDeleted When isCrossPost , whether the source message has been deleted from the original guild Message.suppressEmbeds Whether this message's embeds should be serialized Function Description Message.addReaction Convenience function to add a Unicode emoji reaction represented by a string to the message Message.deleteReaction Convenience function to remove a Unicode emoji reaction represented by a string or other relevant object from the message Message.deleteOwnReaction Convenience function to remove a reaction from the message that was previously added by the bot Message.deleteIgnoringNotFound Convenience function to delete a message and ignore any errors if the message no longer exists Message.delete Convenience function to delete a message after a delay, which does not block the current coroutine or thread Message.getUrl Convenience function to construct the URL for a message Message.parse Parses message content into a list using an Apache Commons StringTokenizer , which supports quotes for individual values with spaces Message.requireChannel Function that ensures a message was sent within a given channel (with some options), responding with an error if not Message.requireGuildChannel Function that ensures a message was not sent privately (with some options), responding with an error if it was Message.respond Convenience function to respond to a user's message, with the option to use either Discord's replies feature or just a mention","title":"Messages"},{"location":"utilities/general/#misc","text":"Function Description runSuspended Convenience function to run a block of code in a coroutine dispatcher, defaulting to Dispatchers.IO - useful for otherwise blocking calls","title":"Misc"},{"location":"utilities/general/#reaction","text":"This utility transforms other types to ReactionEmoji objects. Function Description GuildEmoji.toReaction Transform the given GuildEmoji object into a ReactionEmoji object String.toReaction Transform a String object containing a Unicode emoji into a ReactionEmoji object","title":"Reaction"},{"location":"utilities/general/#restrequest","text":"This utility concerns Ktor's RestRequestException objects. Function Description RestRequestException.hasStatus Check whether the given exception concerns a specific HttpStatusCode RestRequestException.hasStatusCode Check whether the given exception concerns a specific HTTP status code integer RestRequestException.hasNotStatus Check whether the given exception does not concern a specific HttpStatusCode RestRequestException.hasNotStatusCode Check whether the given exception does not concern a specific HTTP status code integer","title":"RestRequest"},{"location":"utilities/general/#string","text":"Function Description String.parseBoolean Parses a String into a Boolean based on its starting character and the locale for the given context (or a given locale) String.splitOn Splits a string into a Pair containing the characters matching the predicate up until its first failure, and the rest of the string","title":"String"},{"location":"utilities/general/#users","text":"Property Description User.createdAt Quick access to a user's creation time, taken from their Snowflake User.profileLink Quick access to a user's profile URL Function Description User.dm Send a private message to a user, returning a Message object if successfull or null if the user has their private messages disabled topRole Retrieve a user's top role, given a guild's Snowflake User?.isNullOrBot Check whether the given User object is null, or a bot","title":"Users"},{"location":"utilities/paginator/","text":"Paginator \u00b6 A fairly common use-case for bots is displaying pages of data - messages can only be so long, and posting too much text at once can be fairly disruptive. To cover this use-case, Kord Extensions provides a fairly extensible paginator. This allows you to customize the embeds used for each page, as well as specifying switchable page groups if you'd like to - for example - allow users to expand the current page into something with more information. The paginator adds a set of reactions below an embed, allowing users to flip between pages, skip to the first or last page, switch between page groups or destroy the paginator when they're done with it. The paginator includes a set of classes that abstract away a fair amount of the logic required, but you can extend any of these classes and customize them to your liking. There are three major classes you'll need to understand: Page , Pages and Paginator . Page \u00b6 The Page class is a light container for embed data, and provides a method used to build the embed used to display the page on Discord. It supports a number of parameters that correspond with embed properties, but only the first one - description - is required. As part of this formatting, the page number and current group will be inserted into the embed footer, if applicable. For this reason, it's wise to keep the footer text for your pages short. Footer text is formatted like this, Page x/y \u2022 group \u2022 given footer text , although you can customize this by overriding the build function in a Page subclass. Pages \u00b6 The Pages class provides a container for your pages and their groups. When creating your pages, you should create an instance of the Pages class (or a subclass) and add pages to it as you go, using the provided functions. The Pages constructor takes a single argument, which is the name of the default group. If not specified, this will be the empty string, \"\" . A group named with the empty string will not be named in the embed footer, but you can change this behaviour by providing a different default group name. The paginator will always inform users when there's more than two groups. Page collection validation Note: In order to be considered valid, a collection of pages must meet the following criteria: It must contain at least one group of pages All page groups must contain the same number of pages If this isn't the case, the paginator will throw an exception when it's created. The following functions are available for use. Function Description addPage Add a page to this collection of pages, defaulting to the default group or using a specified group get Get a page by index, defaulting to the default group or using a specified group validate Check that this collection of pages is valid, throwing if it isn't Paginator \u00b6 The Paginator class ties all of this logic together in a single place, transforming collections of pages into actionable embeds on Discord. Currently, the paginator makes use of reactions directly on Discord, but this will change once Discord provides better mechanisms for dealing with this kind of thing. The first thing to do is create a Paginator instance, with the following constructor parameters. Please note that you must provide either targetChannel or targetMessage . If you supply both, targetChannel will take priority. Name Type Description targetChannel MessageChannelBehavior Channel to send the paginator within targetMessage Message Message to send the paginator in response to pages Pages Collection of pages to paginate pingInReply Boolean When targetMessage is provided, whether to ping the message author in the reply, true by default owner User? If desired, provide a user here and no other users will be able to interact with the paginator timeout Long? If desired, amount of time with no reactions to wait before destroying the paginator keepEmbed Boolean Whether to keep the embed when destroying the paginator, true by default switchEmoji ReactionEmoji The emoji to use to cycle between page groups, by default for two groups or for more than two locale Locale? The Locale object to use for strings, which should be passed in from the getLocale() function in your command's context object Once you've created your paginator, all you need to do is call the send function, and it'll be sent to the channel!","title":"Paginator"},{"location":"utilities/paginator/#paginator","text":"A fairly common use-case for bots is displaying pages of data - messages can only be so long, and posting too much text at once can be fairly disruptive. To cover this use-case, Kord Extensions provides a fairly extensible paginator. This allows you to customize the embeds used for each page, as well as specifying switchable page groups if you'd like to - for example - allow users to expand the current page into something with more information. The paginator adds a set of reactions below an embed, allowing users to flip between pages, skip to the first or last page, switch between page groups or destroy the paginator when they're done with it. The paginator includes a set of classes that abstract away a fair amount of the logic required, but you can extend any of these classes and customize them to your liking. There are three major classes you'll need to understand: Page , Pages and Paginator .","title":"Paginator"},{"location":"utilities/paginator/#page","text":"The Page class is a light container for embed data, and provides a method used to build the embed used to display the page on Discord. It supports a number of parameters that correspond with embed properties, but only the first one - description - is required. As part of this formatting, the page number and current group will be inserted into the embed footer, if applicable. For this reason, it's wise to keep the footer text for your pages short. Footer text is formatted like this, Page x/y \u2022 group \u2022 given footer text , although you can customize this by overriding the build function in a Page subclass.","title":"Page"},{"location":"utilities/paginator/#pages","text":"The Pages class provides a container for your pages and their groups. When creating your pages, you should create an instance of the Pages class (or a subclass) and add pages to it as you go, using the provided functions. The Pages constructor takes a single argument, which is the name of the default group. If not specified, this will be the empty string, \"\" . A group named with the empty string will not be named in the embed footer, but you can change this behaviour by providing a different default group name. The paginator will always inform users when there's more than two groups. Page collection validation Note: In order to be considered valid, a collection of pages must meet the following criteria: It must contain at least one group of pages All page groups must contain the same number of pages If this isn't the case, the paginator will throw an exception when it's created. The following functions are available for use. Function Description addPage Add a page to this collection of pages, defaulting to the default group or using a specified group get Get a page by index, defaulting to the default group or using a specified group validate Check that this collection of pages is valid, throwing if it isn't","title":"Pages"},{"location":"utilities/paginator/#paginator_1","text":"The Paginator class ties all of this logic together in a single place, transforming collections of pages into actionable embeds on Discord. Currently, the paginator makes use of reactions directly on Discord, but this will change once Discord provides better mechanisms for dealing with this kind of thing. The first thing to do is create a Paginator instance, with the following constructor parameters. Please note that you must provide either targetChannel or targetMessage . If you supply both, targetChannel will take priority. Name Type Description targetChannel MessageChannelBehavior Channel to send the paginator within targetMessage Message Message to send the paginator in response to pages Pages Collection of pages to paginate pingInReply Boolean When targetMessage is provided, whether to ping the message author in the reply, true by default owner User? If desired, provide a user here and no other users will be able to interact with the paginator timeout Long? If desired, amount of time with no reactions to wait before destroying the paginator keepEmbed Boolean Whether to keep the embed when destroying the paginator, true by default switchEmoji ReactionEmoji The emoji to use to cycle between page groups, by default for two groups or for more than two locale Locale? The Locale object to use for strings, which should be passed in from the getLocale() function in your command's context object Once you've created your paginator, all you need to do is call the send function, and it'll be sent to the channel!","title":"Paginator"},{"location":"utilities/scheduler/","text":"Scheduler \u00b6 It's fairly often that Discord bots need to schedule some task or job for later. To make this simple (and to try to be accurate about timings), a simple Scheduler class is included with Kord Extensions. This class exists to schedule cancellable delayed Task objects, with callbacks. Scheduler \u00b6 For most purposes, you'll want to create an instance of the Scheduler class. This class takes no arguments, and is its own CoroutineScope . This allows you to easily manage your scheduled tasks as a whole. Function Description callAllNow Execute the callback for all registered Task s immediately schedule Schedule a new Task with callback, with a delay specified in seconds or with a Duration object from kx.time shutdown Cancel all scheduled Task s and cancel the schedule's coroutine scope, making it unusable Task \u00b6 Task objects contain a callback, as well as scheduling information pertaining to that callback. You normally won't want to create these yourself - they're managed by Scheduler objects - but you can do so if you need to. Parameter Description callback Callback to be executed once enough time has passed coroutineScope Optional coroutine scope to launch with, defaulting to the current Kord instance duration How long to wait after starting before calling the callback parent Parent Scheduler object, if any - Task objects remove themselves from their parents on completion pollingSeconds How long to wait between time checks, in seconds - defaults to 1 Property Description running true if the Task is currently waiting for time to pass before execution, or if the callback is executing Function Description callNow Stop waiting and immediately call the callback, without launching - job will be null during execution cancel Stop waiting immediately by cancelling the job cancelAndJoin Stop waiting, cancelling the job and waiting for it to complete join Join the job that's waiting for execution to happen, if any shouldStart Calculate whether it's currently time to start the task start Mark the current time and start waiting until the delay has passed","title":"Scheduler"},{"location":"utilities/scheduler/#scheduler","text":"It's fairly often that Discord bots need to schedule some task or job for later. To make this simple (and to try to be accurate about timings), a simple Scheduler class is included with Kord Extensions. This class exists to schedule cancellable delayed Task objects, with callbacks.","title":"Scheduler"},{"location":"utilities/scheduler/#scheduler_1","text":"For most purposes, you'll want to create an instance of the Scheduler class. This class takes no arguments, and is its own CoroutineScope . This allows you to easily manage your scheduled tasks as a whole. Function Description callAllNow Execute the callback for all registered Task s immediately schedule Schedule a new Task with callback, with a delay specified in seconds or with a Duration object from kx.time shutdown Cancel all scheduled Task s and cancel the schedule's coroutine scope, making it unusable","title":"Scheduler"},{"location":"utilities/scheduler/#task","text":"Task objects contain a callback, as well as scheduling information pertaining to that callback. You normally won't want to create these yourself - they're managed by Scheduler objects - but you can do so if you need to. Parameter Description callback Callback to be executed once enough time has passed coroutineScope Optional coroutine scope to launch with, defaulting to the current Kord instance duration How long to wait after starting before calling the callback parent Parent Scheduler object, if any - Task objects remove themselves from their parents on completion pollingSeconds How long to wait between time checks, in seconds - defaults to 1 Property Description running true if the Task is currently waiting for time to pass before execution, or if the callback is executing Function Description callNow Stop waiting and immediately call the callback, without launching - job will be null during execution cancel Stop waiting immediately by cancelling the job cancelAndJoin Stop waiting, cancelling the job and waiting for it to complete join Join the job that's waiting for execution to happen, if any shouldStart Calculate whether it's currently time to start the task start Mark the current time and start waiting until the delay has passed","title":"Task"}]}